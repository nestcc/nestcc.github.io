<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>辗转相除、扩展欧几里得</title>
    <link href="/2020/08/07/pe-05/"/>
    <url>/2020/08/07/pe-05/</url>
    
    <content type="html"><![CDATA[<h1 id="辗转相除法-欧几里得算法"><a href="#辗转相除法-欧几里得算法" class="headerlink" title="辗转相除法(欧几里得算法)"></a>辗转相除法(欧几里得算法)</h1><blockquote><p>  定理: a和b的最大公因数等于b和a % b的最大公因数.</p><p>  假设a, b != 0,则有gcd(a, b) = gcd(b, a % b).</p></blockquote><p>C++实现:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> (b ? gcd(b, a % b) : a);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b)) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, gcd(a, b));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p>问: 求 $ax + by = 1$ 的一组整数解.</p><p>设<br>$$<br>ax_1 + by_1 = gcd(a, b) \<br>bx_2 + (a % b)y_2 = gcd(b, a % b)<br>$$<br>根据欧几里德原理有 gcd(a,b) = gcd(b,a mod b)</p><p>则:ax1+ by1= bx2+ (a mod b)y2;</p><p>即:ax1+ by1= bx2+ (a - [a / b] * b)y2=ay2+ bx2- [a / b] * by2;</p><p>说明： a-[a/b]*b即为mod运算。[a/b]代表取小于a/b的最大整数。</p><p>也就是ax1+ by1 == ay2+ b(x2- [a / b] *y2);</p><p>根据恒等定理得：<strong>x1=y2; y1=x2- [a / b] *y2</strong>;</p><p>这样我们就得到了求解 x1,y1 的方法：<strong>x1，y1 的值基于 x2，y2</strong>.</p><p>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。</p><p><strong>递归边界：gcd（a,0）=1*a-0*0=a。</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!b) &#123;        *x = <span class="hljs-number">1</span>, *y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">int</span> xx, yy, ret = ex_gcd(b, a % b, &amp;xx, &amp;yy);    *x = yy;    *y = xx - a / b * yy;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b, x, y;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b)) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"gcd(%d, %d) = %d\n"</span>, a, b, ex_gcd(a, b, &amp;x, &amp;y));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d * %d + %d * %d = %d\n"</span>, a, x, b, y, a * x + b * y);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划45</title>
    <link href="/2020/08/07/euler45/"/>
    <url>/2020/08/07/euler45/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-45"><a href="#Problem-45" class="headerlink" title="Problem 45"></a><a href="https://projecteuler.net/problem=45" target="_blank" rel="noopener">Problem 45</a></h1><hr><p><strong>Triangular, pentagonal, and hexagonal</strong></p><p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Triangle</td><td>Tn=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>Pentagonal</td><td>Pn=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>Hexagonal</td><td>Hn=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr></tbody></table><p>It can be verified that T285 = P165 = H143 = 40755.</p><p>Find the next triangle number that is also pentagonal and hexagonal.</p><hr><p>可证明任何一个六边形数字必然是三角形数字，证明略。</p><p>可以遍历六边形数字，判断是不是五边形数字。</p><p>判断是不是五边形数字使用二分法。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Triangele</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Pentagonal</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (<span class="hljs-number">3</span> * n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Hexagonal</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> (*func)(<span class="hljs-keyword">int64_t</span>), <span class="hljs-keyword">int64_t</span> n, <span class="hljs-keyword">int64_t</span> x)</span> </span>&#123; <span class="hljs-comment">// 使用函数指针</span>    <span class="hljs-keyword">int64_t</span> head = <span class="hljs-number">1</span>, tail = n, mid;    <span class="hljs-keyword">while</span> (head &lt;= tail) &#123;        mid = (head + tail) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (func(mid) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (func(mid) &lt; x) head = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> tail = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int64_t</span> n = <span class="hljs-number">143</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        n++; <span class="hljs-comment">// 六边形数字下标</span>        <span class="hljs-keyword">int64_t</span> tmp = Hexagonal(n); <span class="hljs-comment">// 遍历六边形数字</span>                <span class="hljs-comment">// 二分判断是否为五边形数字，左右界为2 * n，和tmp</span>        <span class="hljs-keyword">if</span> (!binary_search(Pentagonal, <span class="hljs-number">2</span> * n, tmp)) <span class="hljs-keyword">continue</span>;         <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%"</span> PRId64 <span class="hljs-string">"\n"</span>, Hexagonal(n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 函数</title>
    <link href="/2020/08/06/func/"/>
    <url>/2020/08/06/func/</url>
    
    <content type="html"><![CDATA[<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>把函数当作参数传入方程中。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*f1)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span> (*f2)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span> (*f3)(<span class="hljs-keyword">int</span>))</span> </span>&#123;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> f1(x);    &#125;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">100</span>) &#123;        <span class="hljs-keyword">return</span> f2(x);    &#125;    <span class="hljs-keyword">return</span> f3(x);&#125;</code></pre><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol><li>边界条件</li><li>处理过程，递归过程</li><li>返回</li></ol><h4 id="与数学归纳法类似"><a href="#与数学归纳法类似" class="headerlink" title="与数学归纳法类似"></a>与数学归纳法类似</h4><ol><li>f(0) 成立                             ==&gt;    边界条件成立</li><li>f(k)成立，f(k+1)成立        ==&gt;    处理过程</li></ol><h1 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h1><ul><li>需要引入&lt;cstdarg&gt;头文件</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, ...)</span></span>;</code></pre><ul><li>va_list                                        =&gt; 变参列表</li><li>va_start()                                   =&gt; a后面的第一个参数</li><li>va_arg()                                     =&gt; 下一个可变参数列表中的参数</li><li>va_end()                                    =&gt; 结束获取可变参数列表的动作</li></ul><p>例：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, ...)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    va_list arg;    va_start(arg, n);    <span class="hljs-keyword">while</span> (n--) &#123;        <span class="hljs-keyword">int</span> tmp = va_arg(arg, <span class="hljs-keyword">int</span>);        <span class="hljs-keyword">if</span> (tmp &gt; ans) ans = tmp;    &#125;    va_end(arg);        <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    max_int(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划3</title>
    <link href="/2020/08/06/euler03/"/>
    <url>/2020/08/06/euler03/</url>
    
    <content type="html"><![CDATA[<h1 id="Largest-prime-factor"><a href="#Largest-prime-factor" class="headerlink" title="Largest prime factor"></a><strong>Largest prime factor</strong></h1><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 600851475143LL</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">2</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n = max_n;    <span class="hljs-keyword">while</span> (i * i &lt;= n) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) ans = i;        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i; <span class="hljs-comment">// 除掉所有为i的质因子，本行之后n与i互质</span>        i++;    &#125;    <span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) ans = n;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划15</title>
    <link href="/2020/08/06/euler15/"/>
    <url>/2020/08/06/euler15/</url>
    
    <content type="html"><![CDATA[<h1 id="Lattice-paths"><a href="#Lattice-paths" class="headerlink" title="Lattice paths"></a><strong>Lattice paths</strong></h1><p>Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.</p><p>How many such routes are there through a 20×20 grid?</p><h4 id="排列组合解决"><a href="#排列组合解决" class="headerlink" title="排列组合解决"></a>排列组合解决</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m = <span class="hljs-number">40</span>, n = <span class="hljs-number">20</span>, ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (m != <span class="hljs-number">20</span> || n) &#123;        <span class="hljs-keyword">if</span> (m != <span class="hljs-number">20</span>) ans *= m--;        <span class="hljs-keyword">if</span> (n &amp;&amp; ans % n == <span class="hljs-number">0</span>) ans /= n--;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu-blog</title>
    <link href="/2020/08/05/ubuntu-blog/"/>
    <url>/2020/08/05/ubuntu-blog/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划8</title>
    <link href="/2020/08/04/EP8/"/>
    <url>/2020/08/04/EP8/</url>
    
    <content type="html"><![CDATA[<h2 id="Largest-product-in-a-series"><a href="#Largest-product-in-a-series" class="headerlink" title="Largest product in a series"></a><strong>Largest product in a series</strong></h2><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><pre><code class="hljs plain">73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450</code></pre><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><pre><code class="hljs css">假设有数组<span class="hljs-selector-attr">[a b c d e f g h]</span>一个大小为3的滑动窗口在其上滑动，则有:<span class="hljs-selector-attr">[a b c]</span>  <span class="hljs-selector-attr">[b c d]</span>    <span class="hljs-selector-attr">[c d e]</span>      <span class="hljs-selector-attr">[d e f]</span>        <span class="hljs-selector-attr">[e f g]</span>          <span class="hljs-selector-attr">[f g h]</span></code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 1000</span><span class="hljs-keyword">char</span> num[max_n + <span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, num + len)) len = <span class="hljs-built_in">strlen</span>(num);    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>, zero = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; num[i]; i++) &#123;        num[i] -= <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (num[i]) p *= num[i];        <span class="hljs-keyword">else</span> zero += <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">13</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (num[i - <span class="hljs-number">13</span>]) p /= num[i - <span class="hljs-number">13</span>];        <span class="hljs-keyword">else</span> zero -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">0</span> &amp;&amp; p &gt; ans) ans = p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划2</title>
    <link href="/2020/08/04/eulerproject-02/"/>
    <url>/2020/08/04/eulerproject-02/</url>
    
    <content type="html"><![CDATA[<h2 id="Even-Fibonacci-numbers-偶斐波那契数"><a href="#Even-Fibonacci-numbers-偶斐波那契数" class="headerlink" title="Even Fibonacci numbers 偶斐波那契数"></a><strong>Even Fibonacci numbers</strong> <strong>偶斐波那契数</strong></h2><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><h1 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h1><p>数学推导可知:<br>$$<br>fib(n) \geq 1.5^n<br>$$<br>可知最多44项就可满足题目</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 44</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4000000</span><span class="hljs-keyword">int</span> fib[max_n + <span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= max_n; i++) &#123;        fib[i] = fib[i - <span class="hljs-number">1</span>] + fib[i - <span class="hljs-number">2</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_n; i++) &#123;        <span class="hljs-keyword">if</span> (fib[i] &lt;= N &amp;&amp; !(fib[i] &amp; <span class="hljs-number">1</span>)) sum += fib[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>空间复杂度O(n)，不好。</p><h1 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h1><p>每次生成只依赖于前两项的值，因此没必要存储全部斐波那契数列。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 4000000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (a + b &lt;=  max_n) &#123;        b = a + b;        a = b - a;        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;        sum += b;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="解3"><a href="#解3" class="headerlink" title="解3"></a>解3</h1><h2 id="滚动数组：可循环利用的数组"><a href="#滚动数组：可循环利用的数组" class="headerlink" title="滚动数组：可循环利用的数组"></a>滚动数组：可循环利用的数组</h2><p>[0, 1] =&gt; [2, 1] =&gt; [2, 3] =&gt; [5, 3] =&gt; ……</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 4000000</span><span class="hljs-keyword">int</span> fib[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (fib[n % <span class="hljs-number">2</span>] + fib[(n - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] &lt;= max_n) &#123;        n++;        fib[n % <span class="hljs-number">2</span>] = fib[(n - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + fib[(n - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>];        <span class="hljs-keyword">if</span> (fib[n % <span class="hljs-number">2</span>] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;        sum += fib[n % <span class="hljs-number">2</span>];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL标准库实现2——Vector 实现</title>
    <link href="/2020/08/03/cpp-stl-vector/"/>
    <url>/2020/08/03/cpp-stl-vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector-介绍"><a href="#vector-介绍" class="headerlink" title="vector 介绍"></a>vector 介绍</h1><p>vector 是 C++ 标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector 是向量类型，它可以容纳多种类型的数据，所以称之为容器。</p><h1 id="vector-类基础"><a href="#vector-类基础" class="headerlink" title="vector 类基础"></a>vector 类基础</h1><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:    T *start_;<span class="hljs-comment">// 表示使用空间的头</span>    T *finish_;<span class="hljs-comment">// 表示使用空间的末尾</span>    T *endofStorage_;<span class="hljs-comment">// 表示可用空间的末尾</span>    <span class="hljs-keyword">typedef</span> Alloc dataAllocator;<span class="hljs-comment">// 表示分配空间</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django ModelAdmin的使用</title>
    <link href="/2020/07/31/django-model-admin/"/>
    <url>/2020/07/31/django-model-admin/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  若想在Admin中管理自己定义的model，需要在app下的admin.py中创建ModelAdmin。</p></blockquote><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-keyword">from</span> myproject.myapp.models <span class="hljs-keyword">import</span> Author<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    <span class="hljs-keyword">pass</span>admin.site.register(Author, AuthorAdmin)</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Author<span class="hljs-meta">@admin.register(Author)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    <span class="hljs-keyword">pass</span></code></pre><p>或者直接</p><pre><code class="hljs pyth">from django.contrib import adminfrom myproject.myapp.models import Authoradmin.site.register(Author)</code></pre><p>注册后可在admin页面中管理’Author’ Model。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="1-fields-exclude"><a href="#1-fields-exclude" class="headerlink" title="1. fields, exclude"></a>1. fields, exclude</h2><p>在编辑页面中包含或除去某些字段</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    fields = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'title'</span>) <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    exclude = (<span class="hljs-string">'birth_date'</span>,)</code></pre><h2 id="2-fieldsets"><a href="#2-fieldsets" class="headerlink" title="2. fieldsets"></a>2. fieldsets</h2><p>如上fields的加强版</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlatPageAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    fieldsets = (        (<span class="hljs-literal">None</span>, &#123;            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'url'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>, <span class="hljs-string">'sites'</span>)        &#125;),        (<span class="hljs-string">'Advanced options'</span>, &#123;            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'registration_required'</span>, <span class="hljs-string">'template_name'</span>),        &#125;),    )</code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的运算符及部分数学函数</title>
    <link href="/2020/07/30/operator/"/>
    <url>/2020/07/30/operator/</url>
    
    <content type="html"><![CDATA[<h1 id="1-位运算符-amp-、-、-、"><a href="#1-位运算符-amp-、-、-、" class="headerlink" title="1. 位运算符(&amp;、|、^、~ )"></a>1. 位运算符(&amp;、|、^、~ )</h1><table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><blockquote><p>  假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p></blockquote><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与操作，按二进制位进行”与”运算。运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符，按二进制位进行”或”运算。运算规则：`0</td><td align="left">0=0;    0</td></tr><tr><td align="left">^</td><td align="left">异或运算符，按二进制位进行”异或”运算。运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">取反运算符，按二进制位进行”取反”运算。运算规则：<code>~1=0;    ~0=1;</code></td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr></tbody></table><h1 id="2-左移右移-lt-lt-、-gt-gt"><a href="#2-左移右移-lt-lt-、-gt-gt" class="headerlink" title="2. 左移右移(&lt;&lt;、&gt;&gt;)"></a>2. 左移右移(&lt;&lt;、&gt;&gt;)</h1><blockquote><p>  假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p></blockquote><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0，相当于原值*2。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃，相当于原值/2。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h1 id="3-下取整-floor"><a href="#3-下取整-floor" class="headerlink" title="3. 下取整 floor()"></a>3. 下取整 floor()</h1><ul><li>头文件math.h</li><li>原型：int floor(double x)</li></ul><h1 id="4-取整数绝对值-abs"><a href="#4-取整数绝对值-abs" class="headerlink" title="4. 取整数绝对值 abs()"></a>4. 取整数绝对值 abs()</h1><ul><li>头文件 stdlib.h</li><li>原型：int abs(int x)</li></ul><h1 id="5-取实数绝对值-fabs"><a href="#5-取实数绝对值-fabs" class="headerlink" title="5. 取实数绝对值 fabs()"></a>5. 取实数绝对值 fabs()</h1><ul><li>math.h</li><li>double fabs(double x)</li></ul><h1 id="6-取e的对数-log"><a href="#6-取e的对数-log" class="headerlink" title="6. 取e的对数 log()"></a>6. 取e的对数 log()</h1><ul><li>math.h</li><li>double log(double x)</li></ul><h1 id="7-取10的对数-log10"><a href="#7-取10的对数-log10" class="headerlink" title="7. 取10的对数 log10()"></a>7. 取10的对数 log10()</h1><ul><li>math.h</li><li>double log19(double x)</li></ul><h1 id="8-arccos，acos"><a href="#8-arccos，acos" class="headerlink" title="8. arccos，acos()"></a>8. arccos，acos()</h1><ul><li>math.h</li><li>double acos(double x)</li></ul><blockquote><p>  acos(-1) = pi</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>operator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装MySQL踩坑</title>
    <link href="/2020/07/29/ubuntu-mysql/"/>
    <url>/2020/07/29/ubuntu-mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="在阿里云Ubuntu主机上安装MySQL"><a href="#在阿里云Ubuntu主机上安装MySQL" class="headerlink" title="在阿里云Ubuntu主机上安装MySQL"></a>在阿里云Ubuntu主机上安装MySQL</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>运行如下命令</p><pre><code class="hljs bash">sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev</code></pre><h2 id="2-改密码（天坑）"><a href="#2-改密码（天坑）" class="headerlink" title="2. 改密码（天坑）"></a>2. 改密码（天坑）</h2><h4 id="1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf"><a href="#1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf" class="headerlink" title="1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf"></a>1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</h4><p>找到如下内容</p><pre><code class="hljs plain">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 skip-grant-tables</code></pre><p>添加 skip-grant-tables</p><p>以安全模式启动MySQL</p><h4 id="2-sudo-service-mysql-restart"><a href="#2-sudo-service-mysql-restart" class="headerlink" title="2. sudo service mysql restart"></a>2. sudo service mysql restart</h4><p>重启mysql服务</p><p>MySQL启动之后就可以不用密码登陆了</p><h4 id="3-查看一下user表"><a href="#3-查看一下user表" class="headerlink" title="3. 查看一下user表"></a>3. 查看一下user表</h4><pre><code class="hljs bash">mysql&gt; select user, plugin from mysql.user;+------------------+-----------------------+| user             | plugin                |+------------------+-----------------------+| root             | auth_socket           || mysql.session    | mysql_native_password || mysql.sys        | mysql_native_password || debian-sys-maint | mysql_native_password |+------------------+-----------------------+4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)</code></pre><h4 id="4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’"><a href="#4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’" class="headerlink" title="4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;"></a>4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;</h4><p>需要将root的plugin修改为mysql_native_password</p><h4 id="5-flush-privileges"><a href="#5-flush-privileges" class="headerlink" title="5. flush privileges;"></a>5. flush privileges;</h4><p>刷新权限</p><h4 id="6-将mysqld-cnf改回，重启MySQL服务"><a href="#6-将mysqld-cnf改回，重启MySQL服务" class="headerlink" title="6. 将mysqld.cnf改回，重启MySQL服务"></a>6. 将mysqld.cnf改回，重启MySQL服务</h4><pre><code class="hljs bas">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 # skip-grant-tables</code></pre><h1 id="3-改编码方式"><a href="#3-改编码方式" class="headerlink" title="3. 改编码方式"></a>3. 改编码方式</h1><p>默认安装MySQL后编码方式不一定是utf8，这时如果我们往数据库中添加含中文的记录会报错。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划1 &amp; 6</title>
    <link href="/2020/07/28/eulerproject-00/"/>
    <url>/2020/07/28/eulerproject-00/</url>
    
    <content type="html"><![CDATA[<h2 id="01-Multiples-of-3-and-5"><a href="#01-Multiples-of-3-and-5" class="headerlink" title="01. Multiples of 3 and 5"></a><strong>01. Multiples of 3 and 5</strong></h2><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><blockquote><p>   暴力解 </p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;        <span class="hljs-keyword">if</span> (is_val(i)) res += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(n)</li></ul><blockquote><p>  等差</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum_3 = (<span class="hljs-number">3</span> + <span class="hljs-number">999</span>) * <span class="hljs-number">333</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_5 = (<span class="hljs-number">5</span> + <span class="hljs-number">995</span>) * <span class="hljs-number">199</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_15 = (<span class="hljs-number">15</span> + <span class="hljs-number">999</span> / <span class="hljs-number">15</span> * <span class="hljs-number">15</span>) * (<span class="hljs-number">999</span> / <span class="hljs-number">15</span>) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum_3 + sum_5 - sum_15);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(1)</li></ul><h2 id="06-Sum-square-difference"><a href="#06-Sum-square-difference" class="headerlink" title="06. Sum square difference"></a><strong>06. Sum square difference</strong></h2><p>The sum of the squares of the first ten natural numbers is,</p><p>12 + 22 + … + 102 = 385</p><p>The square of the sum of the first ten natural numbers is,</p><p>(1 + 2 + … + 10)2 = 552 = 3025</p><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><blockquote><p>  老规矩，暴力解，O(n)</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> sum_of_squ = <span class="hljs-number">0</span>; squ_of_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i += <span class="hljs-number">1</span>) &#123;        sum_of_sqq += i * i;        squ_of_sum += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, squ_of_sum * squ_of_sum - sum_of_squ);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>  去for循环，公式自行百度</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 100</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum2 = <span class="hljs-number">5050</span>;    <span class="hljs-keyword">int</span> sum1 = (<span class="hljs-number">2</span> * n * n * n + <span class="hljs-number">3</span> * n * n + n) / <span class="hljs-number">6</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum2 * sum2 - sum1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a href="https://www.zhihu.com/question/32253765" target="_blank" rel="noopener">正整数的平方和公式是什么？怎么证明？</a></p>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL标准库实现1——模板编程</title>
    <link href="/2020/07/28/cpp-stl-template/"/>
    <url>/2020/07/28/cpp-stl-template/</url>
    
    <content type="html"><![CDATA[<h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="模板的基本语法"><a href="#模板的基本语法" class="headerlink" title="模板的基本语法"></a>模板的基本语法</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>/<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></code></pre><p>template 告诉编译器，接下来是一个模板 ，typename 和 class 都是关键字，在这里二者可以互用没有区别。在<code>&lt; &gt;</code>中 <code>T</code> 叫做模板形参，一旦模板被实例化，<code>T</code> 也会变成具体的类型。</p><h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T  <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span><span class="hljs-function"></span>&#123;    T a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><p>使用：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> a ;     a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><blockquote><p>  如果我们使用<code>add(1,2.0)</code>是会报错的，编译器无法找到<code>add(int,double)</code>。</p></blockquote><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    T a;    <span class="hljs-keyword">public</span>:        <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> T lva, <span class="hljs-keyword">const</span> T rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><p>在程序中给出模板并不能使用它，还必须实例化，比如：</p><pre><code class="hljs c++">Myclass&lt;<span class="hljs-keyword">int</span>&gt; A； <span class="hljs-comment">//用 int 实例化一个类 A</span>Myclass&lt;<span class="hljs-keyword">double</span>&gt; B； <span class="hljs-comment">//用 double 实例化一个类 B</span></code></pre><h2 id="成员模板："><a href="#成员模板：" class="headerlink" title="成员模板："></a>成员模板：</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_3</span>&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Myclass_2</span>;</span>         <span class="hljs-comment">// 声明放在这里，具体定义放在类外进行。</span>        Myclass_2&lt;T&gt; C;          <span class="hljs-comment">// 定义一个Myclass_2 类 A。使用 T 进行实例化</span>&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;class type_3&gt;</span><span class="hljs-class">    <span class="hljs-title">class</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:Myclass_2    &#123;        <span class="hljs-keyword">public</span>:            type_3 value;            <span class="hljs-function">type_3 <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_3 a , <span class="hljs-keyword">const</span> type_3 b)</span> </span>&#123;vlaue = a - b;&#125;    &#125;;</code></pre><h2 id="typename和class的区别"><a href="#typename和class的区别" class="headerlink" title="typename和class的区别"></a>typename和class的区别</h2><p><code>typename</code>和<code>class</code>是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。<strong>因为历史原因，两个是可以通用的。</strong></p><p>例子：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass();        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> test;  <span class="hljs-comment">//定义类型别名</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass2</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass2();        T::test *a  <span class="hljs-comment">// 声明一个指向T::test类型的指针。</span>        <span class="hljs-comment">//   typename T::test * a</span>&#125;</code></pre><p>不能通过编译，因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。</p><p>当然如果这里没有二义性，比如<code>Myclass ::test * a</code> ,加上 typename 是会报错的。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django一些常用操作</title>
    <link href="/2020/07/27/Django/"/>
    <url>/2020/07/27/Django/</url>
    
    <content type="html"><![CDATA[<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="数据中有”-lt-”类似符号"><a href="#数据中有”-lt-”类似符号" class="headerlink" title="数据中有”&lt;”类似符号"></a>数据中有”&lt;”类似符号</h1><p>当传到template中的数据包含”&lt;”之类的符号，例如传入html片段时，若直接使用<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="数据中有”-lt-”类似符号"><a href="#数据中有”-lt-”类似符号" class="headerlink" title="数据中有”&lt;”类似符号"></a>数据中有”&lt;”类似符号</h1><p>当传到template中的数据包含”&lt;”之类的符号，例如传入html片段时，若直接使用{{ content }}会导致”&lt;”被转码，进而使”&lt;”变为”&amp;gt;”。如：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>ssdasdsa<span class="hljs-symbol">&amp;lt;</span>/p<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> // <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ssdasdsa<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>需要改为一下写法：</p><pre><code class="hljs plain">&#123;&#123; content | safe &#125;&#125;</code></pre><p>其中 safe可以防止转意。</p>会导致”&lt;”被转码，进而使”&lt;”变为”&amp;gt;”。如：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>ssdasdsa<span class="hljs-symbol">&amp;lt;</span>/p<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> // <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ssdasdsa<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>需要改为一下写法：</p><pre><code class="hljs plain">&#123;&#123; content | safe &#125;&#125;</code></pre><p>其中 safe可以防止转意。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP的部分知识</title>
    <link href="/2020/06/17/tcpip/"/>
    <url>/2020/06/17/tcpip/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>应用层</p><p>表示层</p><p>会话层</p><p>传输层</p><p>网络层</p><p>链路层</p><p>物理层</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>应用层</p><p>传输层</p><p>网际层</p><p>网络接口层</p><p>硬件层</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="第-1-次握手"><a href="#第-1-次握手" class="headerlink" title="第 1 次握手"></a>第 1 次握手</h2><p>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p><h2 id="第-2-次握手"><a href="#第-2-次握手" class="headerlink" title="第 2 次握手"></a>第 2 次握手</h2><p>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p><h2 id="第-3-次握手"><a href="#第-3-次握手" class="headerlink" title="第 3 次握手"></a>第 3 次握手</h2><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="第1次挥手"><a href="#第1次挥手" class="headerlink" title="第1次挥手"></a>第1次挥手</h2><p>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><h2 id="第2次挥手"><a href="#第2次挥手" class="headerlink" title="第2次挥手"></a>第2次挥手</h2><p>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><h2 id="第3次挥手"><a href="#第3次挥手" class="headerlink" title="第3次挥手"></a>第3次挥手</h2><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><h2 id="第4次挥手"><a href="#第4次挥手" class="headerlink" title="第4次挥手"></a>第4次挥手</h2><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>2. 为什么不能用两次握手进行连接？</strong></p><p>我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>  现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><blockquote><p>  Linux 环境下可用tcpdump查看整个过程。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
