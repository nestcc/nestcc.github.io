<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>&#39;Ubuntu安装MySQL踩坑&#39;</title>
    <link href="/2020/07/29/ubuntu-mysql/"/>
    <url>/2020/07/29/ubuntu-mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="在阿里云Ubuntu主机上安装MySQL"><a href="#在阿里云Ubuntu主机上安装MySQL" class="headerlink" title="在阿里云Ubuntu主机上安装MySQL"></a>在阿里云Ubuntu主机上安装MySQL</h1><h2 id="1-运行如下命令"><a href="#1-运行如下命令" class="headerlink" title="1. 运行如下命令"></a>1. 运行如下命令</h2><pre><code class="hljs bash">sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev</code></pre><h2 id="2-改密码（天坑）"><a href="#2-改密码（天坑）" class="headerlink" title="2. 改密码（天坑）"></a>2. 改密码（天坑）</h2><h4 id="1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf"><a href="#1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf" class="headerlink" title="1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf"></a>1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</h4><p>找到如下内容</p><pre><code class="hljs plain">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 skip-grant-tables</code></pre><p>添加 skip-grant-tables</p><p>以安全模式启动MySQL</p><h4 id="2-sudo-service-mysql-restart"><a href="#2-sudo-service-mysql-restart" class="headerlink" title="2. sudo service mysql restart"></a>2. sudo service mysql restart</h4><p>重启mysql服务</p><p>MySQL启动之后就可以不用密码登陆了</p><h4 id="3-查看一下user表"><a href="#3-查看一下user表" class="headerlink" title="3. 查看一下user表"></a>3. 查看一下user表</h4><pre><code class="hljs bash">mysql&gt; select user, plugin from mysql.user;+------------------+-----------------------+| user             | plugin                |+------------------+-----------------------+| root             | auth_socket           || mysql.session    | mysql_native_password || mysql.sys        | mysql_native_password || debian-sys-maint | mysql_native_password |+------------------+-----------------------+4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)</code></pre><h4 id="4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’"><a href="#4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’" class="headerlink" title="4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;"></a>4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;</h4><p>需要将root的plugin修改为mysql_native_password</p><h4 id="5-flush-privileges"><a href="#5-flush-privileges" class="headerlink" title="5. flush privileges;"></a>5. flush privileges;</h4><p>刷新权限</p><h4 id="6-将mysqld-cnf改回，重启MySQL服务"><a href="#6-将mysqld-cnf改回，重启MySQL服务" class="headerlink" title="6. 将mysqld.cnf改回，重启MySQL服务"></a>6. 将mysqld.cnf改回，重启MySQL服务</h4><pre><code class="hljs bas">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 # skip-grant-tables</code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>django-auth</title>
    <link href="/2020/07/29/django-auth/"/>
    <url>/2020/07/29/django-auth/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
      <tag>Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Project Euler Problem 1 &amp; Problem 6</title>
    <link href="/2020/07/28/eulerproject-00/"/>
    <url>/2020/07/28/eulerproject-00/</url>
    
    <content type="html"><![CDATA[<h2 id="01-Multiples-of-3-and-5"><a href="#01-Multiples-of-3-and-5" class="headerlink" title="01. Multiples of 3 and 5"></a><strong>01. Multiples of 3 and 5</strong></h2><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><blockquote><p>   暴力解 </p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;        <span class="hljs-keyword">if</span> (is_val(i)) res += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(n)</li></ul><blockquote><p>  等差</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum_3 = (<span class="hljs-number">3</span> + <span class="hljs-number">999</span>) * <span class="hljs-number">333</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_5 = (<span class="hljs-number">5</span> + <span class="hljs-number">995</span>) * <span class="hljs-number">199</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_15 = (<span class="hljs-number">15</span> + <span class="hljs-number">999</span> / <span class="hljs-number">15</span> * <span class="hljs-number">15</span>) * (<span class="hljs-number">999</span> / <span class="hljs-number">15</span>) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum_3 + sum_5 - sum_15);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(1)</li></ul><h2 id="06-Sum-square-difference"><a href="#06-Sum-square-difference" class="headerlink" title="06. Sum square difference"></a><strong>06. Sum square difference</strong></h2><p>The sum of the squares of the first ten natural numbers is,</p><p>12 + 22 + … + 102 = 385</p><p>The square of the sum of the first ten natural numbers is,</p><p>(1 + 2 + … + 10)2 = 552 = 3025</p><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><blockquote><p>  老规矩，暴力解，O(n)</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> sum_of_squ = <span class="hljs-number">0</span>; squ_of_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i += <span class="hljs-number">1</span>) &#123;        sum_of_sqq += i * i;        squ_of_sum += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, squ_of_sum * squ_of_sum - sum_of_squ);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>  去for循环，公式自行百度</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 100</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum2 = <span class="hljs-number">5050</span>;    <span class="hljs-keyword">int</span> sum1 = (<span class="hljs-number">2</span> * n * n * n + <span class="hljs-number">3</span> * n * n + n) / <span class="hljs-number">6</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum2 * sum2 - sum1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a href="https://www.zhihu.com/question/32253765" target="_blank" rel="noopener">正整数的平方和公式是什么？怎么证明？</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++STL标准库实现1——模板编程</title>
    <link href="/2020/07/28/cpp-stl/"/>
    <url>/2020/07/28/cpp-stl/</url>
    
    <content type="html"><![CDATA[<h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="模板的基本语法"><a href="#模板的基本语法" class="headerlink" title="模板的基本语法"></a>模板的基本语法</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>/<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></code></pre><p>template 告诉编译器，接下来是一个模板 ，typename 和 class 都是关键字，在这里二者可以互用没有区别。在<code>&lt; &gt;</code>中 <code>T</code> 叫做模板形参，一旦模板被实例化，<code>T</code> 也会变成具体的类型。</p><h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T  <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span><span class="hljs-function"></span>&#123;    T a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><p>使用：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> a ;     a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><blockquote><p>  如果我们使用<code>add(1,2.0)</code>是会报错的，编译器无法找到<code>add(int,double)</code>。</p></blockquote><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    T a;    <span class="hljs-keyword">public</span>:        <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> T lva, <span class="hljs-keyword">const</span> T rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><p>在程序中给出模板并不能使用它，还必须实例化，比如：</p><pre><code class="hljs c++">Myclass&lt;<span class="hljs-keyword">int</span>&gt; A； <span class="hljs-comment">//用 int 实例化一个类 A</span>Myclass&lt;<span class="hljs-keyword">double</span>&gt; B； <span class="hljs-comment">//用 double 实例化一个类 B</span></code></pre><h2 id="成员模板："><a href="#成员模板：" class="headerlink" title="成员模板："></a>成员模板：</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_3</span>&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Myclass_2</span>;</span>         <span class="hljs-comment">// 声明放在这里，具体定义放在类外进行。</span>        Myclass_2&lt;T&gt; C;          <span class="hljs-comment">// 定义一个Myclass_2 类 A。使用 T 进行实例化</span>&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;class type_3&gt;</span><span class="hljs-class">    <span class="hljs-title">class</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:Myclass_2    &#123;        <span class="hljs-keyword">public</span>:            type_3 value;            <span class="hljs-function">type_3 <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_3 a , <span class="hljs-keyword">const</span> type_3 b)</span> </span>&#123;vlaue = a - b;&#125;    &#125;;</code></pre><h2 id="typename和class的区别"><a href="#typename和class的区别" class="headerlink" title="typename和class的区别"></a>typename和class的区别</h2><p><code>typename</code>和<code>class</code>是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。<strong>因为历史原因，两个是可以通用的。</strong></p><p>例子：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass();        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> test;  <span class="hljs-comment">//定义类型别名</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass2</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass2();        T::test *a  <span class="hljs-comment">// 声明一个指向T::test类型的指针。</span>        <span class="hljs-comment">//   typename T::test * a</span>&#125;</code></pre><p>不能通过编译，因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。</p><p>当然如果这里没有二义性，比如<code>Myclass ::test * a</code> ,加上 typename 是会报错的。</p>]]></content>
    
    
    <categories>
      
      <category>DEV</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Django一些常用操作</title>
    <link href="/2020/07/27/Django/"/>
    <url>/2020/07/27/Django/</url>
    
    <content type="html"><![CDATA[<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP的部分知识</title>
    <link href="/2020/06/17/tcpip/"/>
    <url>/2020/06/17/tcpip/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>应用层</p><p>表示层</p><p>会话层</p><p>传输层</p><p>网络层</p><p>链路层</p><p>物理层</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>应用层</p><p>传输层</p><p>网际层</p><p>网络接口层</p><p>硬件层</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="第-1-次握手"><a href="#第-1-次握手" class="headerlink" title="第 1 次握手"></a>第 1 次握手</h2><p>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p><h2 id="第-2-次握手"><a href="#第-2-次握手" class="headerlink" title="第 2 次握手"></a>第 2 次握手</h2><p>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p><h2 id="第-3-次握手"><a href="#第-3-次握手" class="headerlink" title="第 3 次握手"></a>第 3 次握手</h2><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="第1次挥手"><a href="#第1次挥手" class="headerlink" title="第1次挥手"></a>第1次挥手</h2><p>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><h2 id="第2次挥手"><a href="#第2次挥手" class="headerlink" title="第2次挥手"></a>第2次挥手</h2><p>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><h2 id="第3次挥手"><a href="#第3次挥手" class="headerlink" title="第3次挥手"></a>第3次挥手</h2><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><h2 id="第4次挥手"><a href="#第4次挥手" class="headerlink" title="第4次挥手"></a>第4次挥手</h2><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>2. 为什么不能用两次握手进行连接？</strong></p><p>我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>  现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><blockquote><p>  Linux 环境下可用tcpdump查看整个过程。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
