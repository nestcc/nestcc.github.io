<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Django一些常用操作</title>
    <link href="/2020/07/27/Django/"/>
    <url>/2020/07/27/Django/</url>
    
    <content type="html"><![CDATA[<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP的部分知识</title>
    <link href="/2020/06/17/tcpip/"/>
    <url>/2020/06/17/tcpip/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>应用层</p><p>表示层</p><p>会话层</p><p>传输层</p><p>网络层</p><p>链路层</p><p>物理层</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>应用层</p><p>传输层</p><p>网际层</p><p>网络接口层</p><p>硬件层</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="第-1-次握手"><a href="#第-1-次握手" class="headerlink" title="第 1 次握手"></a>第 1 次握手</h2><p>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p><h2 id="第-2-次握手"><a href="#第-2-次握手" class="headerlink" title="第 2 次握手"></a>第 2 次握手</h2><p>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p><h2 id="第-3-次握手"><a href="#第-3-次握手" class="headerlink" title="第 3 次握手"></a>第 3 次握手</h2><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="第1次挥手"><a href="#第1次挥手" class="headerlink" title="第1次挥手"></a>第1次挥手</h2><p>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><h2 id="第2次挥手"><a href="#第2次挥手" class="headerlink" title="第2次挥手"></a>第2次挥手</h2><p>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><h2 id="第3次挥手"><a href="#第3次挥手" class="headerlink" title="第3次挥手"></a>第3次挥手</h2><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><h2 id="第4次挥手"><a href="#第4次挥手" class="headerlink" title="第4次挥手"></a>第4次挥手</h2><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>2. 为什么不能用两次握手进行连接？</strong></p><p>我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>  现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><blockquote><p>  Linux 环境下可用tcpdump查看整个过程。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
