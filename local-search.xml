<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Neuroinformatics and Neurotechnologies</title>
    <link href="/2020/12/07/neuro-test/"/>
    <url>/2020/12/07/neuro-test/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Science-“Neuroinformatics”-what-is-it"><a href="#1-Science-“Neuroinformatics”-what-is-it" class="headerlink" title="1.Science “Neuroinformatics” -  what is it?"></a>1.Science “Neuroinformatics” -  what is it?</h1><p>modern theory about principles and new mathematical models of information processing, which based on the biological prototypes and mechanisms of human brain activities</p><h1 id="2-Artificial-intellect-in-technical-systems"><a href="#2-Artificial-intellect-in-technical-systems" class="headerlink" title="2.Artificial intellect in technical  systems."></a>2.Artificial intellect in technical  systems.</h1><p>A set of scientific branches which aims to modeling of reasonable intellectual action in human mind.  </p><ol><li><strong>Representation and accumulation of knowledge,</strong> </li><li><strong>The ability of reasoning to retrieve relevant information</strong></li><li><strong>The ability of adaptation by learning and self-organization</strong></li><li><strong>Optimal team behavior for goal achievement or hierarchy of targets, role models</strong></li><li><strong>Meaning analysis, semantic, crisp logic, rules of inference, emotions</strong></li></ol><h1 id="3-Paradigms-of-Neuroinformatics"><a href="#3-Paradigms-of-Neuroinformatics" class="headerlink" title="3.Paradigms of Neuroinformatics."></a>3.Paradigms of Neuroinformatics.</h1><p><strong>Pattern Manipulation Paradigm in Brain Computer</strong></p><p>The main difference between human and traditional computer comes from the fact that humans perceive everything as a pattern, whereas for a machine everything is digitals data.  </p><h1 id="4-Neurocomputer-and-artificial-neural-networks"><a href="#4-Neurocomputer-and-artificial-neural-networks" class="headerlink" title="4. Neurocomputer and artificial neural networks"></a>4. Neurocomputer and artificial neural networks</h1><h2 id="Brain-like-computer"><a href="#Brain-like-computer" class="headerlink" title="Brain-like computer"></a>Brain-like computer</h2><p>is a mathematical model of humane-brain principles of computations. This computer consists of those  elements which can be called the biological neuron prototypes, which are interconnected by direct links called connections and which cooperate to perform parallel distributed processing (PDP) in order to solve a desired computational task.</p><p>Neurocomputer may be described as  a mathematical model which has been created in the image and likeness of human brain. Mathematicians suggest dramatically new high-performance models of massive parallelism in data processing and data storage, ways of analysis and calculus results interpretation, formal models creation and knowledge data, artificial intelligent systems. </p><h2 id="ANN"><a href="#ANN" class="headerlink" title="ANN"></a>ANN</h2><p>ANN is an assembly of a simple processing elements – neurons which are interconnected by direct links and which cooperate in order to solve a desired computational task.</p><p>Every neuron of ANN can be interpreted as an elementary processing unit with multiple inputs and non-linear transformation of bioelectrical signal excitations .</p><h1 id="5-Formal-neurons-and-its-biological-prototype"><a href="#5-Formal-neurons-and-its-biological-prototype" class="headerlink" title="5.Formal neurons and its biological prototype."></a>5.Formal neurons and its biological prototype.</h1><p>  More general math model of ANN theory is known as the basic or <strong>Formal neuron</strong>. It can be describe as a multi-input nonlinear transformer with weighted interconnections, also called synaptic weights or strengths (<em>w<strong>1</strong>,w<strong>2</strong>, …,<strong>w</strong>n</em>  ). The cell body (soma) is represented by a nonlinear limiting or threshold activation function . </p><ol><li><p><strong>Soma</strong> <strong>or</strong> <strong>body cell</strong> <strong>-</strong> is a large, round central body in which almost all the logical functions of the neuron are realized.</p></li><li><p><strong>The axon</strong> <strong>(output**</strong>)**, is a nerve fibre attached to the soma which can serve as a final output channel of the neuron. An axon is usually highly branched.</p></li><li><p><strong>The dendrites</strong> <strong>(inputs)-</strong> represent a highly branching tree of fibres. These long irregularly shaped nerve fibres (processes) are attached to the soma. </p></li><li><p><strong>Synapses</strong> are specialized contacts on a neuron which are the termination points for the axons from other neurons. </p></li></ol><h1 id="6-Mathematical-interpretation-of-excitation-nonlinear-activation-and-dynamic-behavior-of-artificial-neuron"><a href="#6-Mathematical-interpretation-of-excitation-nonlinear-activation-and-dynamic-behavior-of-artificial-neuron" class="headerlink" title="6. Mathematical interpretation of excitation, nonlinear activation and dynamic behavior of artificial neuron."></a>6. Mathematical interpretation of excitation, nonlinear activation and dynamic behavior of artificial neuron.</h1><p>In artificial neural networks, the <strong>activation function</strong> of a node defines the output of that node given an input or set of inputs. A standard integrated circuit can be seen as a digital network of activation functions that can be “ON” (1) or “OFF” (0), depending on input. This is similar to the behavior of the linear perceptron in neural networks.</p><h2 id="excitation"><a href="#excitation" class="headerlink" title="excitation"></a>excitation</h2><p><img src="../_img/Snipaste_2020-12-07_10-17-52.png" srcset="/img/loading.gif" alt="Snipaste_2020-12-07_10-17-52"></p><h2 id="nonlinear-activation"><a href="#nonlinear-activation" class="headerlink" title="nonlinear activation"></a>nonlinear activation</h2><p><img src="../_img/Snipaste_2020-12-07_10-17-52.png" srcset="/img/loading.gif" alt="Snipaste_2020-12-07_10-17-52"></p><h2 id="dynamic-behavior"><a href="#dynamic-behavior" class="headerlink" title="dynamic behavior"></a>dynamic behavior</h2><p><img src="../_img/Snipaste_2020-12-07_10-24-29.png" srcset="/img/loading.gif" alt="Snipaste_2020-12-07_10-24-29"></p><h1 id="7-Types-of-artificial-neuron-models"><a href="#7-Types-of-artificial-neuron-models" class="headerlink" title="7.Types of artificial neuron models"></a>7.Types of artificial neuron models</h1><p>Depending on the specific model used they may be called a <strong>semi-linear unit</strong>, <strong>Nv neuron</strong>, <strong>binary neuron</strong>, <strong>linear threshold function</strong>, or <strong>McCulloch–Pitts</strong> (<strong>MCP</strong>) <strong>neuron</strong>.</p><h1 id="8-Artificial-Neural-networks-ANN-linear-and-non-linear-models"><a href="#8-Artificial-Neural-networks-ANN-linear-and-non-linear-models" class="headerlink" title="8.Artificial Neural networks (ANN): linear and non-linear models."></a>8.Artificial Neural networks (ANN): linear and non-linear models.</h1><p>Linear models are usually some linear transformation applied to the input whose parameters needs to be learned, like classification whose decision boundary looks like the hyper-plane, i.e. labels are [nearly] linearly separable.</p><p>In the neural nets, you apply such transformation to the input, and then right after that, you pass the resulting vector to the non-linear function. Why do we do a such thing? Most of the processes in nature are very complex for various reasons. One such reason is that there are always some hidden variables that we don’t know about (or simply can’t observe), which have great impact on the output of the process. Because of all this, we can’t only use matrix multiplications in our neural networks to solve this problem. That’s why we use some non-linear functions on top of linear transformations (feeding the weight-input product to the sigmoid, ReLU, etc.) to create non-linear decision boundaries in hope to fit and generalize at the same time.</p><h1 id="9-Topology-of-ANN"><a href="#9-Topology-of-ANN" class="headerlink" title="9. Topology of ANN."></a>9. Topology of ANN.</h1><blockquote><p><a href="https://towardsdatascience.com/the-mostly-complete-chart-of-neural-networks-explained-3fb6f2367464" target="_blank" rel="noopener">Full</a></p></blockquote><ol><li>Perceptron</li><li>Feed forward neural networks</li><li>DFF neural networks</li><li>Recurrent Neural Networks</li><li>LSTM (long/ short term memory)</li></ol><h1 id="10-Learning-paradigms-of-ANN"><a href="#10-Learning-paradigms-of-ANN" class="headerlink" title="10.Learning paradigms of ANN."></a>10.Learning paradigms of ANN.</h1><blockquote><p> <a href="https://medium.com/swlh/learning-paradigms-in-neural-networks-30854975aa8d" target="_blank" rel="noopener">Link</a></p></blockquote><h2 id="Supervised-Learning"><a href="#Supervised-Learning" class="headerlink" title="Supervised Learning"></a>Supervised Learning</h2><p>In supervised learning, we have a very clear and defined goal to predict something using our data. In this manner, we usually use this approach to solve problems of classification or regression.</p><h2 id="Unsupervised-Learning"><a href="#Unsupervised-Learning" class="headerlink" title="Unsupervised Learning"></a>Unsupervised Learning</h2><p>In unsupervised learning, the goal is to discover patterns and trends within a dataset and then use those patterns to make predictions about new data. Within the context of a neural network, the goal is to determine the organization of the dataset it is fed.</p><h2 id="Reinforcement-Learning"><a href="#Reinforcement-Learning" class="headerlink" title="Reinforcement Learning"></a>Reinforcement Learning</h2><p>This style of learning is distinct from the other two because it has a specific goal that it is pushing the machine to move towards. There is a specific outcome that is expected, the machine chooses and learns the most optimal path to achieve it. The way this is accomplished is through providing the machine with rewards and punishments based on its performance that culminate in a long-term end-goal. Rewards and punishment signals are only received by the machine when the machine achieves a new state. Instantaneous feedback is not a part of this paradigm of learning.</p>]]></content>
    
    
    
    <tags>
      
      <tag>master&#39;s course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux用户管理</title>
    <link href="/2020/10/28/linux-user-1/"/>
    <url>/2020/10/28/linux-user-1/</url>
    
    <content type="html"><![CDATA[<h1 id="重要配置文件"><a href="#重要配置文件" class="headerlink" title="重要配置文件"></a>重要配置文件</h1><table><thead><tr><th>文件</th><th>内容</th></tr></thead><tbody><tr><td>/etc/passwd</td><td>用户，密码位，用户编号，归组编号，姓名，$HOME，$SHELL</td></tr><tr><td>/etc/shadow</td><td>用户，已加密密码，密码改动信息，密码策略</td></tr><tr><td>/etc/group</td><td>群组名，密码位，群组编号，组内用户</td></tr><tr><td>/etc/gshadow</td><td>群组密码相关文件</td></tr><tr><td>/etc/sudoers</td><td>用户名，权限定义，权限(sudo)</td></tr></tbody></table><h1 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h1><pre><code class="hljs plain">root:x:0:0:root:&#x2F;root:.&#x2F;shdaemon:x:1:1:daemon:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;sbin&#x2F;nologinbin:x:2:2:bin:&#x2F;bin:&#x2F;usr&#x2F;sbin&#x2F;nologinsys:x:3:3:sys:&#x2F;dev:&#x2F;usr&#x2F;sbin&#x2F;nologinsync:x:4:65534:sync:&#x2F;bin:&#x2F;bin&#x2F;sync</code></pre><table><thead><tr><th>root</th><th>x</th><th>0</th><th>0</th><th>root</th><th>/root</th><th>./sh</th></tr></thead><tbody><tr><td>账号名称</td><td>密码</td><td>uid</td><td>gid</td><td>用户信息</td><td>$HOME</td><td>$SHELL</td></tr></tbody></table><h1 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h1><pre><code class="hljs plain">root:$6$YUw2gL...&#x2F;&#x2F;:18472:0:99999:7:::daemon:*:18113:0:99999:7:::bin:*:18113:0:99999:7:::sys:*:18113:0:99999:7:::sync:*:18113:0:99999:7:::games:*:18113:0:99999:7:::</code></pre><table><thead><tr><th>root</th><th>$6…//</th><th>18472</th><th>0</th><th>99999</th><th>7</th><th>null</th><th>null</th><th>Null</th></tr></thead><tbody><tr><td>账户名称</td><td>加密后的密码</td><td>修改密码的日期</td><td>密码不可改动时间</td><td>密码需重新修改时间</td><td>密码变更期限提前警告</td><td>密码过期宽限时间</td><td>账户失效日期</td><td>保留</td></tr></tbody></table><h1 id="etc-group"><a href="#etc-group" class="headerlink" title="/etc/group"></a>/etc/group</h1><pre><code class="hljs plain">root:x:0:daemon:x:1:bin:x:2:sys:x:3:adm:x:4:syslogtty:x:5:</code></pre><table><thead><tr><th>root</th><th>x</th><th>0</th><th>null</th></tr></thead><tbody><tr><td>组名</td><td>密码位</td><td>gid</td><td>组内用户</td></tr></tbody></table><h1 id="etc-gshadow"><a href="#etc-gshadow" class="headerlink" title="/etc/gshadow"></a>/etc/gshadow</h1><pre><code class="hljs plain">root:*::daemon:*::bin:*::sys:*::adm:*::syslog</code></pre><table><thead><tr><th>root</th><th>*</th><th>null</th><th>Null</th></tr></thead><tbody><tr><td>组名</td><td>密码</td><td>管理员</td><td>组内用户</td></tr></tbody></table><h1 id="chsh-更改用户shell"><a href="#chsh-更改用户shell" class="headerlink" title="chsh 更改用户shell"></a>chsh 更改用户shell</h1><pre><code class="hljs bash">chsh -s Shell &lt;username&gt;</code></pre><h1 id="用户管理相关命令"><a href="#用户管理相关命令" class="headerlink" title="用户管理相关命令"></a>用户管理相关命令</h1><table><thead><tr><th>命令</th><th>说明</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>su</td><td>切换用户</td><td>sudo</td><td>临时切换root用户</td></tr><tr><td>passwd</td><td>设定用户密码</td><td>gpasswd</td><td>设定群组密码</td></tr><tr><td>chsh</td><td>切换shell</td><td>usermod</td><td>修改用户账号</td></tr><tr><td>useradd</td><td>新建用户</td><td>userdel</td><td>删除用户</td></tr><tr><td>Id</td><td>显示用户信息</td><td>…</td><td>…</td></tr></tbody></table><h1 id="su-切换用户"><a href="#su-切换用户" class="headerlink" title="su 切换用户"></a>su 切换用户</h1><pre><code class="hljs shell">su [-lmpfc] &lt;username&gt;</code></pre><ul><li>- | -l : 重新登陆</li><li>-m | -p : 不更改环境变量</li><li>-c command : 切换后执行命令，并退出</li></ul><h1 id="sudo-临时切换到root"><a href="#sudo-临时切换到root" class="headerlink" title="sudo 临时切换到root"></a>sudo 临时切换到root</h1><pre><code class="hljs shell">sudo [-siul] &lt;command&gt;</code></pre><ul><li>-s : 切换为root shell</li><li>-i : 切换到root shell，并初始化</li><li>-u username | did : 执行命令的身份</li><li>-l : 显示自己的权限</li></ul><h1 id="passwd-设定用户密码"><a href="#passwd-设定用户密码" class="headerlink" title="passwd 设定用户密码"></a>passwd 设定用户密码</h1><pre><code class="hljs shell">passwd [-dleSxnf] &lt;username&gt;</code></pre><ul><li>-d : 清除密码</li><li>-l : 锁定账户</li><li>-e : 使密码过期</li><li>-S : 显示密码认证信息</li><li>-x days : 密码修改后最大使用天数</li><li>-n days : 密码修改间隔时间</li><li>-f : 更改用户信息</li><li>-i : 密码过期后宽限时间</li></ul><h1 id="gpasswd-设置组群及组群密码"><a href="#gpasswd-设置组群及组群密码" class="headerlink" title="gpasswd 设置组群及组群密码"></a>gpasswd 设置组群及组群密码</h1><pre><code class="hljs shell">gpassed [-adrAM] &lt;groupname&gt;</code></pre><ul><li>-a username : 将用户加入组群</li><li>-d username : 将用户从组群中移除</li><li>-r : 删除密码</li><li>-A username : 将用户设置为组群管理员</li><li>-M username1, username2, … : 设置组群成员</li></ul><h1 id="useradd-添加用户"><a href="#useradd-添加用户" class="headerlink" title="useradd 添加用户"></a>useradd 添加用户</h1><pre><code class="hljs shell">useradd [-dmMsugGnefcD] &lt;username&gt;</code></pre><ul><li>-d dir : 指定$HOME</li><li>-m : 自动建立$HOME</li><li>-M : 不自动建立$HOME</li><li>-s shell : 设置用户登陆shell</li><li>-u uid : 设置用户id</li><li>-g groupname : 设置用户归属组群</li><li>-G groupname : 设置用户归属附加组群</li><li>-n : 不建立以用户名为组群名称的组群</li><li>-e days : 设置账号过期时间，绝对时间</li><li>-f days : 缓冲时间，days天后关闭账号</li><li>-c string : 设置用户备注</li><li>-D [exp] : 更改预设值</li></ul><p>/etc/login.defs 新建用户规则</p><p>/etc/skel 新建用户默认文件</p><h1 id="userdel-删除用户"><a href="#userdel-删除用户" class="headerlink" title="userdel 删除用户"></a>userdel 删除用户</h1><pre><code class="hljs shell">userdel -r &lt;username&gt;</code></pre><ul><li>-r : 删除用户相关文件和目录（邮件，家目录）</li></ul><h1 id="usermod-命令"><a href="#usermod-命令" class="headerlink" title="usermod 命令"></a>usermod 命令</h1><pre><code class="hljs shell">usermod [-cdefgGlLsuU] &lt;username&gt;</code></pre><ul><li>-l username : 修改用户账号名称</li><li>-L : 锁定用户密码，使密码无效</li><li>-s shell : 修改用户登陆后所使用的shell</li><li>-u did : 修改用户uid</li><li>-U : 解除密码锁定 </li></ul><h1 id="Id-命令"><a href="#Id-命令" class="headerlink" title="Id 命令"></a>Id 命令</h1><pre><code class="hljs shell">id [-gGnru] &lt;username&gt;</code></pre><ul><li>-g : 下属所属组ID</li><li>-G : 显示附加组ID</li><li>-n : 显示用户，所属组码，或附加群组的名称</li><li>-u : 显示用户ID</li><li>-r : 显示实际ID</li></ul>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>course</tag>
      
      <tag>linux</tag>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仿Google Test测试框架——1</title>
    <link href="/2020/10/22/Ncctest1-1/"/>
    <url>/2020/10/22/Ncctest1-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-何为Google-Test"><a href="#1-何为Google-Test" class="headerlink" title="1. 何为Google Test"></a>1. 何为Google Test</h1><blockquote><p>Google Test是基于xUnit架构的C ++编程语言的单元测试库。该库是根据BSD 3条款许可发布的。它可以针对各种POSIX和Windows平台进行编译，允许对C源代码和C ++源代码进行单元测试，而只需对源代码进行最少的修改。这些测试本身可以一次运行一个，甚至可以一次调用全部运行。(维基百科)</p></blockquote><h1 id="2-如何安装及使用"><a href="#2-如何安装及使用" class="headerlink" title="2. 如何安装及使用"></a>2. 如何安装及使用</h1><ol><li><p>Google test 没有即开即用的版本，使用需要先使用cmake编译原项目才能使用，故我们需先准备cmake环境。</p></li><li><p>之后克隆GitHub仓库：</p><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/google/googletest.git</code></pre></li><li><p>之后运行如下命令进行编译</p><pre><code class="hljs bash">mkdir mybuild       <span class="hljs-comment"># Create a directory to hold the build output.</span><span class="hljs-built_in">cd</span> mybuildcmake <span class="hljs-variable">$&#123;GTEST_DIR&#125;</span>  <span class="hljs-comment"># Generate native build scripts.</span></code></pre></li><li><p>安装完成。。。</p></li></ol><h1 id="3-如何使用Google-Test"><a href="#3-如何使用Google-Test" class="headerlink" title="3. 如何使用Google Test"></a>3. 如何使用Google Test</h1><ol><li>需要在任意一段c++代码中引入头文件&lt;gtest/gtest.h&gt;。</li><li>使用TEST()宏创建测试用例。</li><li>在主函数中调用RUN_ALL_TESTS()函数。</li></ol><p>如下：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-comment">// using namespace std;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;gtest/gtest.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">return</span> a +b;&#125;TEST(testCase, test0)&#123;    EXPECT_EQ(add(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>), <span class="hljs-number">5</span>);    EXPECT_EQ(add(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), <span class="hljs-number">7</span>);    ASSERT_EQ(add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>), <span class="hljs-number">8</span>);    EXPECT_EQ(add(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>), <span class="hljs-number">6</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;  testing::InitGoogleTest(&amp;argc, argv);  <span class="hljs-keyword">return</span> RUN_ALL_TESTS();&#125;</code></pre><p>编译运行后就可得到如下结果：</p><pre><code class="hljs shell">[==========] Running 1 test from 1 test suite.[----------] Global test environment set-up.[----------] 1 test from testCase[ RUN      ] testCase.test0first.cpp:19: FailureExpected equality of these values:  add(1, 3)    Which is: 4  8[  FAILED  ] testCase.test0 (0 ms)[----------] 1 test from testCase (0 ms total)[----------] Global test environment tear-down[==========] 1 test from 1 test suite ran. (0 ms total)[  PASSED  ] 0 tests.[  FAILED  ] 1 test, listed below:[  FAILED  ] testCase.test0 1 FAILED TEST</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C结构体</title>
    <link href="/2020/08/22/cstructer-1/"/>
    <url>/2020/08/22/cstructer-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C结构体"><a href="#C结构体" class="headerlink" title="C结构体"></a>C结构体</h1><p>C的结构体用于设计复杂类型。例如：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> &#123;</span>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">20</span>];    <span class="hljs-keyword">int</span> age;    <span class="hljs-keyword">char</span> gender;    <span class="hljs-keyword">float</span> <span class="hljs-built_in">height</span>;&#125;;</code></pre><p>其中<code>struct person</code>为变量名，而并非<code>person</code>。</p><p><code>.</code>为直接引用符，<code>-&gt;</code>为间接引用符。</p><h1 id="分配空间原则"><a href="#分配空间原则" class="headerlink" title="分配空间原则"></a>分配空间原则</h1><p><strong>默认情况下：</strong></p><ol><li>找对齐标准<br>先找一个占用空间最大的元素。例如在<code>person</code>中，最大的是<code>int</code>或<code>float</code>类型（4字节），4字节就是对其因素，每次开辟4个字节。<code>name</code>是字符串，不考虑。</li><li>给每一个元素开辟空间。<br><code>name</code>占20个字节，开5次，<br><code>gender</code>占1个字节，但也分配4个字节。</li></ol><p><strong>使用宏：</strong></p><p><strong>例：</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node1</span> &#123;</span>    <span class="hljs-keyword">char</span> a;    <span class="hljs-keyword">char</span> b;    <span class="hljs-keyword">int</span> c;&#125;;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">node2</span> &#123;</span>    <span class="hljs-keyword">char</span> a;    <span class="hljs-keyword">int</span> c;    <span class="hljs-keyword">char</span> b;&#125;;</code></pre><p>以4字节为单位，<code>node1</code>先开辟4字节，可以放入<code>a</code>，<code>b</code>，之后再开辟4字节，放入<code>c</code>，总共占用8字节。</p><p>同样以4字节为单位，<code>node2</code>先开辟4字节，仅可放入<code>a</code>，再开辟4字节，放入<code>c</code>，最后还需4字节放入<code>b</code>，总共占用12字节。</p><h1 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h1><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-keyword">register</span> &#123;    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> byte1;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> byte2;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> byte3;        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> byte4;    &#125; bytes;    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> number;&#125;</code></pre><p>与结构体不同，共用体占用空间为占用空间最大元素的空间，上述共用体中，共占用4字节。如果改变byte1的内容，则number的内容也会改变。</p><p>例如：</p><pre><code class="hljs c++"><span class="hljs-keyword">union</span> node &#123;    <span class="hljs-keyword">double</span> a;    <span class="hljs-keyword">char</span> b;    <span class="hljs-keyword">int</span> c;&#125;</code></pre><p>占用情况：</p><table><thead><tr><th>a</th><th>b</th><th>c</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td></td><td>1</td></tr><tr><td>2</td><td></td><td>2</td></tr><tr><td>3</td><td></td><td>3</td></tr><tr><td>4</td><td></td><td></td></tr><tr><td>5</td><td></td><td></td></tr><tr><td>6</td><td></td><td></td></tr><tr><td>7</td><td></td><td></td></tr></tbody></table><h1 id="判断大端机、小端机"><a href="#判断大端机、小端机" class="headerlink" title="判断大端机、小端机"></a>判断大端机、小端机</h1><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_little</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;    <span class="hljs-keyword">return</span> ((<span class="hljs-keyword">char</span>*)&amp;num)[<span class="hljs-number">0</span>];&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>struct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ep44</title>
    <link href="/2020/08/22/ep44-1/"/>
    <url>/2020/08/22/ep44-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-44"><a href="#Problem-44" class="headerlink" title="Problem 44"></a><a href="https://projecteuler.net/problem=44" target="_blank" rel="noopener">Problem 44</a></h1><hr><p><strong>Pentagon numbers</strong></p><p>Pentagonal numbers are generated by the formula, <code>Pn=n(3n−1)/2</code>. The first ten pentagonal numbers are:</p><p>1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …</p><p>It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70 − 22 = 48, is not pentagonal.</p><p>Find the pair of pentagonal numbers, <code>Pj</code> and <code>Pk</code>, for which their sum and difference are pentagonal and <code>D = |Pk − Pj|</code> is  minimised; what is the value of D?</p><h1 id="动态枚举上界"><a href="#动态枚举上界" class="headerlink" title="动态枚举上界"></a>动态枚举上界</h1><p>先枚举出五边形数字<br>$$<br>1, 5, 12, 22, 35, 51, 70, 92, 117, 145, …<br>$$<br>双指针从前向后走，如果差值大于D则直接跳过。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cinttypes&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">penta</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (<span class="hljs-number">3</span> * n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bs_penta</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> (*func)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int64_t</span> n, <span class="hljs-keyword">int64_t</span> x)</span> </span>&#123;    <span class="hljs-keyword">int64_t</span> left = <span class="hljs-number">1</span>, right = n, mid;    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (func(mid) == x) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">if</span> (func(mid) &lt; x) &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int64_t</span> index = <span class="hljs-number">2</span>, res = INT32_MAX, pi, pj;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int64_t</span> i = <span class="hljs-number">2</span>; penta(i) - penta(i - <span class="hljs-number">1</span>) &lt; res; i += <span class="hljs-number">1</span>) &#123;        pi = penta(i);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int64_t</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j -= <span class="hljs-number">1</span>) &#123;            pj = penta(j);            <span class="hljs-keyword">if</span> (pj - pi &gt;= res) &#123;                <span class="hljs-keyword">break</span>;            &#125;            <span class="hljs-keyword">int</span> flag = <span class="hljs-number">1</span>;            flag = bs_penta(penta, <span class="hljs-number">2</span> * i, pi + pj);            flag = flag &amp;&amp; bs_penta(penta, i, pi - pj);            flag &amp;&amp; (res = pi - pj);        &#125;    &#125;    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线性筛</title>
    <link href="/2020/08/18/prime-1/"/>
    <url>/2020/08/18/prime-1/</url>
    
    <content type="html"><![CDATA[<h1 id="质数筛缺陷"><a href="#质数筛缺陷" class="headerlink" title="质数筛缺陷"></a>质数筛缺陷</h1><h1 id="线性筛思想"><a href="#线性筛思想" class="headerlink" title="线性筛思想"></a>线性筛思想</h1><p>线性筛的总体思想是用一个整数<code>M</code>去标记合数<code>N</code>，其中<code>N</code>和<code>M</code>具有如下性质</p><ol><li><code>N</code>中最小质数为<code>P</code></li><li><code>N</code>可以表示为<code>P*M</code></li><li><code>P</code>一定小于等于<code>M</code>中最小的因子</li><li>利用<code>M</code>（所有不大于M中最小的质数）去标记<code>P*M</code></li></ol><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 30</span><span class="hljs-keyword">int</span> nums[N + <span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i += <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (!nums[i]) &#123; nums[++nums[<span class="hljs-number">0</span>]] = i; &#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= nums[<span class="hljs-number">0</span>]; j += <span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">if</span> (nums[j] * i &gt;= N) &#123; <span class="hljs-keyword">break</span>; &#125;nums[nums[j] * i] = nums[j];<span class="hljs-keyword">if</span> (i % nums[j] == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre><h1 id="需要判断质数的情况"><a href="#需要判断质数的情况" class="headerlink" title="需要判断质数的情况"></a>需要判断质数的情况</h1><p>在<code>nums</code>数组中，前<code>nums[0]</code>项已经被用于存放质数，因此我们在需要判断一个数字是否是质数的时候无法通过<code>nums</code>数组判断，因此我们需要另外一个prime数组。</p><pre><code class="hljs c++"><span class="hljs-keyword">int</span> nums[N];<span class="hljs-keyword">int</span> prime[N] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span> &#125;;<span class="hljs-comment">// 务必将前三项重置为1，1，0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; N; i += <span class="hljs-number">1</span>) &#123;        <span class="hljs-keyword">if</span> (!nums[i]) &#123; nums[++nums[<span class="hljs-number">0</span>]] = i; &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= nums[<span class="hljs-number">0</span>] ; j += <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">if</span> (nums[j] * i &gt;= N) &#123; <span class="hljs-keyword">break</span>; &#125;            nums[nums[j] * i] = i;            prime[nums[j] * i] = i;            <span class="hljs-keyword">if</span> (i % nums[j] == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">break</span>; &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> ;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Primes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++字符串</title>
    <link href="/2020/08/18/cpp-string-1/"/>
    <url>/2020/08/18/cpp-string-1/</url>
    
    <content type="html"><![CDATA[<h1 id="c-字符串"><a href="#c-字符串" class="headerlink" title="c++字符串"></a>c++字符串</h1><p>头文件：string.h</p><table><thead><tr><th>func</th><th>discription</th></tr></thead><tbody><tr><td>strlen(str)</td><td></td></tr><tr><td>strcmp(str1, str2)</td><td></td></tr><tr><td>strcpy(dest, src)</td><td>src拷贝到dest中</td></tr><tr><td>strncmp(str1, str2, n)</td><td>安全的字符串比较</td></tr><tr><td>strncpy(str1, str2, n)</td><td>安全的字符串拷贝</td></tr><tr><td>memcpy(str1, str2, n)</td><td>内存拷贝</td></tr><tr><td>memcmp(str1, str2, n)</td><td>内存比较</td></tr><tr><td>memset(str1, c, n)</td><td>内存设置</td></tr></tbody></table><p>内存拷贝不需要两个参数类型相同，他会直接复制内存中的数据，其运行速度最快。</p><p><strong>尽量不要使用不安全的拷贝和比较，因为c的字符串拷贝机制是以’\0’为结束的，那么如果src比dest长，那么拷贝将会越界。</strong></p>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++宏定义</title>
    <link href="/2020/08/15/cpp-define-1/"/>
    <url>/2020/08/15/cpp-define-1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何使用宏"><a href="#如何使用宏" class="headerlink" title="如何使用宏"></a>如何使用宏</h1><p>所有带“#”的代码都是宏，例如<strong>#include &lt;cstdio&gt;</strong>就是一个宏。</p><p>我们有如下几种定义宏的方法。</p><h2 id="定义符号常量"><a href="#定义符号常量" class="headerlink" title="定义符号常量"></a>定义符号常量</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415926</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_N 10000</span></code></pre><h2 id="定义表达式"><a href="#定义表达式" class="headerlink" title="定义表达式"></a>定义表达式</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX(a, b) (a) &gt; (b) ? (a) : (b)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S(a, b) a * b</span></code></pre><h2 id="定义代码段"><a href="#定义代码段" class="headerlink" title="定义代码段"></a>定义代码段</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> P(a) &#123; \</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, a); \&#125;</code></pre><h2 id="变参宏"><a href="#变参宏" class="headerlink" title="变参宏"></a>变参宏</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> log(frm, args...) &#123;\</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s : %d] %s = "</span>, __func__, __LINE__, #args);\<span class="hljs-built_in">printf</span>(frm, ##args);\<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>);\&#125;</code></pre><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>宏仅作代码替换操作，不做逻辑处理</strong></p><p>例如：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> S(a, b) a * b</span></code></pre><p>如果我们调用：</p><pre><code class="hljs c++">S(<span class="hljs-number">2</span> + <span class="hljs-number">3</span>, <span class="hljs-number">4</span> + <span class="hljs-number">5</span>)</code></pre><p>代码会被替换成：</p><pre><code class="hljs c++"><span class="hljs-number">2</span> + <span class="hljs-number">3</span> * <span class="hljs-number">4</span> + <span class="hljs-number">5</span></code></pre><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> DEBUG</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> log(frm, args...) &#123;\</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"[%s : %d] %s = "</span>, __func__, __LINE__, #args);\<span class="hljs-built_in">printf</span>(frm, ##args);\<span class="hljs-built_in">print</span>(<span class="hljs-string">"\n"</span>);\&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> log(frm, args...)</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span></code></pre><p>这样我们就定义了一个log宏，可以在debug时期打印log，如：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>;    <span class="hljs-built_in">log</span>(<span class="hljs-string">"%d"</span>, a);    <span class="hljs-built_in">log</span>(<span class="hljs-string">"Hello world"</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如果我们进行完debug，不想再要打印信息了，只需要将”#define DEBUG”注释掉即可。这样log宏就会展开成空。</p><p>我们可以使用命令添加宏，如：</p><pre><code class="hljs bash">g++ -DDEBUG xxx.cpp// 用于debug，有<span class="hljs-built_in">log</span>信息</code></pre><pre><code class="hljs bash">g++ xxx.cpp // 用于执行，没有<span class="hljs-built_in">log</span>信息</code></pre><h1 id="预定义的宏"><a href="#预定义的宏" class="headerlink" title="预定义的宏"></a>预定义的宏</h1><table><thead><tr><th>说明</th><th>函数</th></tr></thead><tbody><tr><td>__DATE__</td><td>日期：M mm dd yyyy</td></tr><tr><td>__TIME__</td><td>时间：hh:mm:ss</td></tr><tr><td>__LINE__</td><td>行号</td></tr><tr><td>__FILE__</td><td>文件名</td></tr><tr><td>__func__</td><td>函数名/非标准</td></tr><tr><td>__FUNC__</td><td>函数名/非标准</td></tr><tr><td>__PRETTY_FUNCTION__</td><td>更详细的函数信息/非标准</td></tr></tbody></table><h1 id="条件式编译"><a href="#条件式编译" class="headerlink" title="条件式编译"></a>条件式编译</h1><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>#ifdef DEBUG</td><td>是否定义了DEBUG</td></tr><tr><td>#idndef DEBUG</td><td>是否没有定义DEBUG</td></tr><tr><td>#if MAX_N == 5</td><td>宏MAX_N是否等于5</td></tr><tr><td>#elif MAX_N == 4</td><td>否则宏MAX_N是否等于4</td></tr><tr><td>#else</td><td></td></tr><tr><td>#endif</td><td></td></tr></tbody></table><h1 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h1><p><img src="C:%5CmyProjects%5CnccBlog%5Csource%5Ccppdefine%5Ccppdefineproc.png" srcset="/img/loading.gif" alt="cppdefineproc"></p><p>宏的处理发生在预处理阶段，在编译阶段之前。</p><p>c++编译器在预处理阶段会把所有的宏替换为代码，例如将”stdio.h”文件内容拷贝进来。</p><p>由于宏的处理发生在预编译阶段，宏的执行速度也是最快的，其处理速度远快于函数。</p>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2020/08/15/binary-search-1/"/>
    <url>/2020/08/15/binary-search-1/</url>
    
    <content type="html"><![CDATA[<h1 id="如何查找元素"><a href="#如何查找元素" class="headerlink" title="如何查找元素"></a>如何查找元素</h1><p>现有一个单调数组，和一个待查找的元素x，如何何种查找法具有最好的时间复杂度。</p><p><img src=".._img%5CSnipaste_2020-08-15_09-27-41.png" srcset="/img/loading.gif" alt="Snipaste_2020-08-15_09-27-41"></p><p>最简单，也是最容易想到的方法是一个一个在数组里查找。但如果该数组长度为1亿的话，我们就需要查找1亿次，效率不好。</p><h1 id="附加1：0，1问题"><a href="#附加1：0，1问题" class="headerlink" title="附加1：0，1问题"></a>附加1：0，1问题</h1><p>假设有如下一个数组：<br>$$<br>0, 0, 0, … , 0, 0, 1, 1, 1, 1, …<br>$$<br>如何找到第一个1？</p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>left <code>&lt;</code> right:</p><p><strong>mid = (left + right) / 2</strong></p><p>mid -&gt; 0 : left = mid + 1</p><p>mid -&gt; 1 : right = <code>mid</code></p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bs01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (arr[mid] == <span class="hljs-number">1</span>) &#123;            right = mid;        &#125;        <span class="hljs-keyword">else</span> &#123;            left = mid + <span class="hljs-number">1</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> left;&#125;</code></pre><h1 id="附加2：1，0问题"><a href="#附加2：1，0问题" class="headerlink" title="附加2：1，0问题"></a>附加2：1，0问题</h1><p>假设有如下一个数组：<br>$$<br>1, 1, 1, 1, 0, 0, 0, 0, …<br>$$<br>如何找到最后一个1？</p><h2 id="二分法-1"><a href="#二分法-1" class="headerlink" title="二分法"></a>二分法</h2><p>left &lt; right:</p><p><strong>mid = (left + right + 1) / 2</strong> </p><p>mid -&gt; 1 : left = mid</p><p>mid -&gt; 0 : right = mid - 1</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bs01</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> target)</span> </span>&#123;    <span class="hljs-keyword">int</span> mid;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        mid = (left + right + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;        <span class="hljs-keyword">if</span> (arr[mid] == <span class="hljs-number">0</span>) &#123;            left = mid;        &#125;        <span class="hljs-keyword">else</span> &#123;            right = mid - <span class="hljs-number">1</span>;        &#125;    &#125;        <span class="hljs-keyword">return</span> left;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>array</tag>
      
      <tag>search</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++数组与指针</title>
    <link href="/2020/08/13/cpp-pointer-1/"/>
    <url>/2020/08/13/cpp-pointer-1/</url>
    
    <content type="html"><![CDATA[<h1 id="C-中的数组与传参"><a href="#C-中的数组与传参" class="headerlink" title="C++中的数组与传参"></a>C++中的数组与传参</h1><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>我们写下如下代码：</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span> &#125;;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr = %p, &amp;arr[0] = %p\n"</span>, arr, &amp;arr[<span class="hljs-number">0</span>]);     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"arr + 1 = %p, &amp;arr[1] = %p, arr + 2 = %p\n"</span>, arr + <span class="hljs-number">1</span>, &amp;arr[<span class="hljs-number">1</span>], arr + <span class="hljs-number">2</span>);    <span class="hljs-keyword">char</span> *p = (<span class="hljs-keyword">char</span> *) arr;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"p = %p, p + 1 = %p\n"</span>, p, p + <span class="hljs-number">1</span>);        <span class="hljs-keyword">int</span> n = <span class="hljs-number">123</span>;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(n) = %lu\n"</span>, <span class="hljs-keyword">sizeof</span>(n));    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"sizeof(arr) = %lu\n"</span>, <span class="hljs-keyword">sizeof</span>(arr));        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>输出</p><pre><code class="hljs plain">arr &#x3D; 000000A634B3FA68, &amp;arr[0] &#x3D; 000000A634B3FA68arr + 1 &#x3D; 000000A634B3FA6C, &amp;arr[1] &#x3D; 000000A634B3FA6C, arr + 2 &#x3D; 000000A634B3FA70p &#x3D; 000000A634B3FA68, p + 1 &#x3D; 000000A634B3FA69sizeof(n) &#x3D; 4sizeof(arr) &#x3D; 40</code></pre><p>可以看到:</p><ul><li><p>第一行全部为数组首地址的值，</p></li><li><p>第二行分别为arr[1]和arr[2]的地址，我们可以看出[0]，[1]和[2]的地址相差4，即int类型的size。</p></li><li><p>第三行arr + 1和&amp;arr[1]是一样的，这说明arr[1]和*(arr + 1)是等价的，都可以用于访问arr[1]。</p></li></ul><p>因此我们在传参的时候只需要传数组的首地址即可。</p><p>如：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *a)</span> </span>&#123;    <span class="hljs-built_in">print</span>(<span class="hljs-string">"a[0] = %d, a[1] = %d"</span>, a[<span class="hljs-number">0</span>], a[<span class="hljs-number">1</span>]);    ...&#125;</code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p>写下如下代码</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> num[<span class="hljs-number">10</span>][<span class="hljs-number">2</span>];    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"num = %p, num + 1 = %p\n"</span>, num, num + <span class="hljs-number">1</span>);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>执行结果</p><pre><code class="hljs plain">num &#x3D; 0000008797F9F870, num + 1 &#x3D; 0000008797F9F878</code></pre><p>说明num + 1是num第二行的首地址。</p><p>因此不能使用如下方法传二维数组</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> **p)</span> </span>&#123;    ...&#125;</code></pre><p>需要使用</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">3</span>])</span> </span>&#123;    ...&#125;</code></pre><h1 id="n维数组"><a href="#n维数组" class="headerlink" title="n维数组"></a>n维数组</h1><p>与二维数组类似</p><pre><code class="hljs plain">int num[20][3][2];</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*p)[<span class="hljs-number">3</span>][<span class="hljs-number">2</span>])</span> </span>&#123;    ...&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>array</tag>
      
      <tag>pointer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCPIP粘包拆包</title>
    <link href="/2020/08/11/tcpip-package/"/>
    <url>/2020/08/11/tcpip-package/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP粘包或拆包的原因"><a href="#TCP粘包或拆包的原因" class="headerlink" title="TCP粘包或拆包的原因"></a>TCP粘包或拆包的原因</h1><p>1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。</p><p>2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。</p><p>3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。</p><p>4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</p><h1 id="粘包、拆包解决办法"><a href="#粘包、拆包解决办法" class="headerlink" title="粘包、拆包解决办法"></a>粘包、拆包解决办法</h1><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。</p><p>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。</p><p>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p>]]></content>
    
    
    <categories>
      
      <category>knowledge</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TCP/IP</tag>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实现c语言中的printf()</title>
    <link href="/2020/08/11/my-printf/"/>
    <url>/2020/08/11/my-printf/</url>
    
    <content type="html"><![CDATA[<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>我们将整个函数封装进一个头文件中，命名为”customprt.h”。在这个头文件中我们定义一个函数，命名为”custom_prt”。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdarg&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">custom_prt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* frm, ...)</span> </span>&#123;    ...&#125;</code></pre><h1 id="首先实现打印不带占位符的字符串"><a href="#首先实现打印不带占位符的字符串" class="headerlink" title="首先实现打印不带占位符的字符串"></a>首先实现打印不带占位符的字符串</h1><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">custom_prt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* frm)</span> </span>&#123;<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUTC(a) putchar(a), count += 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; frm[i]; i++) &#123;PUTC(frm[i]);&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> PUTC</span>&#125;</code></pre><p>我们可以使用putc()打印每一个字符。并把它封装进一个宏中。</p><h1 id="接下来我们处理存在占位符的情况"><a href="#接下来我们处理存在占位符的情况" class="headerlink" title="接下来我们处理存在占位符的情况"></a>接下来我们处理存在占位符的情况</h1><h2 id="发现”-…”时的处理"><a href="#发现”-…”时的处理" class="headerlink" title="发现”%…”时的处理"></a>发现”%…”时的处理</h2><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'%'</span>) &#123;<span class="hljs-comment">// 处理"%d","%s","%%"</span>    i += <span class="hljs-number">1</span>;<span class="hljs-comment">// 跳过"%.."后的'd','s','%'</span>    ...    &#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则直接打印</span>    PUTC(frm[i]);    count += <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="处理”-”，打印一个’-’"><a href="#处理”-”，打印一个’-’" class="headerlink" title="处理”%%”，打印一个’%’"></a>处理”%%”，打印一个’%’</h2><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'%'</span>) &#123;    PUTC(frm[i]);    count += <span class="hljs-number">1</span>;&#125;</code></pre><h2 id="处理”-d”"><a href="#处理”-d”" class="headerlink" title="处理”%d”"></a>处理”%d”</h2><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'d'</span>) &#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x = va_arg(arg, <span class="hljs-keyword">int</span>);<span class="hljs-comment">// 处理INT32_MAX，INT32_MIN，需使用long long</span>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 负数情况处理</span>        PUTC(<span class="hljs-string">'-'</span>);        x = - x;        count += <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">char</span> tmp[<span class="hljs-number">20</span>];<span class="hljs-comment">// 以字符串形式存储数字</span>    <span class="hljs-keyword">int</span> digit = <span class="hljs-number">0</span>;<span class="hljs-comment">// 总位数</span>    <span class="hljs-keyword">do</span> &#123;        tmp[digit] = x % <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;<span class="hljs-comment">// 将每一位存入tmp中，此时为倒序，如123存入后为['3','2','1']</span>        digit += <span class="hljs-number">1</span>;<span class="hljs-comment">// 位数 + 1</span>        x /= <span class="hljs-number">10</span>;    &#125; <span class="hljs-keyword">while</span> (x);    count += digit;    <span class="hljs-keyword">while</span> (digit--) &#123;<span class="hljs-comment">// 倒序打印</span>        PUTC(tmp[digit]);    &#125;&#125;</code></pre><h2 id="处理”-s”"><a href="#处理”-s”" class="headerlink" title="处理”%s”"></a>处理”%s”</h2><pre><code class="hljs c++"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'s'</span>) &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* chr = va_arg(arg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; chr[i]; i += <span class="hljs-number">1</span>) &#123;        PUTC(chr[i]);        count += <span class="hljs-number">1</span>;    &#125;&#125;</code></pre><h2 id="完整程序"><a href="#完整程序" class="headerlink" title="完整程序"></a>完整程序</h2><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdarg&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">custom_prt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* frm, ...)</span> </span>&#123;<span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;va_list arg;va_start(arg, frm);<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PUTC(a) putchar(a), count += 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; frm[i]; i++) &#123;<span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'%'</span>) &#123;<span class="hljs-comment">// 处理"%d","%s","%%"</span>i += <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'%'</span>) &#123;PUTC(frm[i]);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'d'</span>) &#123;<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> x = va_arg(arg, <span class="hljs-keyword">int</span>);<span class="hljs-comment">// 处理INT32_MAX，INT32_MIN，需使用long long</span><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 负数情况处理</span>PUTC(<span class="hljs-string">'-'</span>);x = - x;&#125;<span class="hljs-keyword">char</span> tmp[<span class="hljs-number">20</span>];<span class="hljs-comment">// 以字符串形式存储数字</span><span class="hljs-keyword">int</span> digit = <span class="hljs-number">0</span>;<span class="hljs-comment">// 总位数</span><span class="hljs-keyword">do</span> &#123;tmp[digit] = x % <span class="hljs-number">10</span> + <span class="hljs-string">'0'</span>;<span class="hljs-comment">// 将每一位存入tmp中，此时为倒序，如123存入后为['3','2','1']</span>digit += <span class="hljs-number">1</span>;<span class="hljs-comment">// 位数 + 1</span>x /= <span class="hljs-number">10</span>;&#125; <span class="hljs-keyword">while</span> (x);<span class="hljs-keyword">while</span> (digit--) &#123;<span class="hljs-comment">// 倒序打印</span>PUTC(tmp[digit]);&#125;&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (frm[i] == <span class="hljs-string">'s'</span>) &#123;<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* chr = va_arg(arg, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; chr[i]; i += <span class="hljs-number">1</span>) &#123;PUTC(chr[i]);&#125;&#125;&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// 否则直接打印</span>PUTC(frm[i]);&#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> PUTC</span><span class="hljs-keyword">return</span> count;&#125;</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"customprt.h"</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cinttypes&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;custom_prt(<span class="hljs-string">"%d\n"</span>, INT32_MAX);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, INT32_MAX);custom_prt(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">-5</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, <span class="hljs-number">-5</span>);custom_prt(<span class="hljs-string">"%d\n"</span>, INT32_MIN);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, INT32_MIN);<span class="hljs-keyword">int</span> n = <span class="hljs-number">-500</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"has %d\n"</span>, custom_prt(<span class="hljs-string">"%d%s\n"</span>, n, <span class="hljs-string">"aa"</span>));<span class="hljs-built_in">printf</span>(<span class="hljs-string">"has %d\n"</span>, <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d%s\n"</span>, n, <span class="hljs-string">"aa"</span>));<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果</p><pre><code class="hljs plain">21474836472147483647-5-5-2147483648-2147483648-500aahas 7-500aahas 7</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划17</title>
    <link href="/2020/08/08/euler17/"/>
    <url>/2020/08/08/euler17/</url>
    
    <content type="html"><![CDATA[<h2 id="Number-letter-counts"><a href="#Number-letter-counts" class="headerlink" title="Number letter counts"></a><strong>Number letter counts</strong></h2><p>If the numbers 1 to 5 are written out in words: one, two, three, four, five, then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.</p><p>If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?</p><p><strong>NOTE:</strong> Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains 23 letters and 115 (one hundred and fifteen) contains 20 letters. The use of “and” when writing out numbers is in compliance with British usage.</p><hr><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">int</span> num1[<span class="hljs-number">20</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>,  <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">8</span> &#125;;<span class="hljs-keyword">int</span> num2[<span class="hljs-number">10</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">6</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_letter</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">20</span>) &#123; <span class="hljs-keyword">return</span> num1[num]; &#125;<span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">100</span>) &#123; <span class="hljs-keyword">return</span> num2[num / <span class="hljs-number">10</span>] + num1[num % <span class="hljs-number">10</span>]; &#125;<span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">1000</span>) &#123;<span class="hljs-keyword">if</span> (num % <span class="hljs-number">100</span> == <span class="hljs-number">0</span>) &#123; <span class="hljs-keyword">return</span> num1[num / <span class="hljs-number">100</span>] + <span class="hljs-number">7</span>; &#125;<span class="hljs-keyword">else</span> &#123; <span class="hljs-keyword">return</span> num1[num / <span class="hljs-number">100</span>] + <span class="hljs-number">10</span> + get_letter(num % <span class="hljs-number">100</span>); &#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">11</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i += <span class="hljs-number">1</span>) &#123;res += get_letter(i);&#125;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划5</title>
    <link href="/2020/08/08/euler05/"/>
    <url>/2020/08/08/euler05/</url>
    
    <content type="html"><![CDATA[<h2 id="Smallest-multiple"><a href="#Smallest-multiple" class="headerlink" title="Smallest multiple"></a><strong>Smallest multiple</strong></h2><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.</p><p>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p><hr><p>问题可等同于求1-20的最小公倍数。</p><p>方法：lcm(1, 2) =&gt; lcm(lcm(1, 2), 3) =&gt; lcm(lcm(…), 20)</p><p>其中，lcm(a, b) = (a * b) / gcd(a, b)</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 20</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> (b ? gcd(b, a % b) : a);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= max_n; i += <span class="hljs-number">1</span>) &#123;        ans *= i / gcd(ans, i);    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>辗转相除、扩展欧几里得</title>
    <link href="/2020/08/07/pe-05/"/>
    <url>/2020/08/07/pe-05/</url>
    
    <content type="html"><![CDATA[<h1 id="辗转相除法-欧几里得算法"><a href="#辗转相除法-欧几里得算法" class="headerlink" title="辗转相除法(欧几里得算法)"></a>辗转相除法(欧几里得算法)</h1><blockquote><p>  定理: a和b的最大公因数等于b和a % b的最大公因数.</p><p>  假设a, b != 0,则有gcd(a, b) = gcd(b, a % b).</p></blockquote><p>C++实现:</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">return</span> (b ? gcd(b, a % b) : a);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b)) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, gcd(a, b));    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得"></a>扩展欧几里得</h1><p>问: 求 $ax + by = 1$ 的一组整数解.</p><p>设<br>$$<br>ax_1 + by_1 = gcd(a, b) \<br>bx_2 + (a % b)y_2 = gcd(b, a % b)<br>$$<br>根据欧几里德原理有 gcd(a,b) = gcd(b,a mod b)</p><p>则:ax1+ by1= bx2+ (a mod b)y2;</p><p>即:ax1+ by1= bx2+ (a - [a / b] * b)y2=ay2+ bx2- [a / b] * by2;</p><p>说明： a-[a/b]*b即为mod运算。[a/b]代表取小于a/b的最大整数。</p><p>也就是ax1+ by1 == ay2+ b(x2- [a / b] *y2);</p><p>根据恒等定理得：<strong>x1=y2; y1=x2- [a / b] *y2</strong>;</p><p>这样我们就得到了求解 x1,y1 的方法：<strong>x1，y1 的值基于 x2，y2</strong>.</p><p>上面的思想是以递归定义的，因为 gcd 不断的递归求解一定会有个时候 b=0，所以递归可以结束。</p><p><strong>递归边界：gcd（a,0）=1*a-0*0=a。</strong></p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ex_gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> *x, <span class="hljs-keyword">int</span> *y)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!b) &#123;        *x = <span class="hljs-number">1</span>, *y = <span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-keyword">int</span> xx, yy, ret = ex_gcd(b, a % b, &amp;xx, &amp;yy);    *x = yy;    *y = xx - a / b * yy;    <span class="hljs-keyword">return</span> ret;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a, b, x, y;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>, &amp;a, &amp;b)) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"gcd(%d, %d) = %d\n"</span>, a, b, ex_gcd(a, b, &amp;x, &amp;y));        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d * %d + %d * %d = %d\n"</span>, a, x, b, y, a * x + b * y);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划45</title>
    <link href="/2020/08/07/euler45/"/>
    <url>/2020/08/07/euler45/</url>
    
    <content type="html"><![CDATA[<h1 id="Problem-45"><a href="#Problem-45" class="headerlink" title="Problem 45"></a><a href="https://projecteuler.net/problem=45" target="_blank" rel="noopener">Problem 45</a></h1><hr><p><strong>Triangular, pentagonal, and hexagonal</strong></p><p>Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Triangle</td><td>Tn=n(n+1)/2</td><td>1, 3, 6, 10, 15, …</td></tr><tr><td>Pentagonal</td><td>Pn=n(3n−1)/2</td><td>1, 5, 12, 22, 35, …</td></tr><tr><td>Hexagonal</td><td>Hn=n(2n−1)</td><td>1, 6, 15, 28, 45, …</td></tr></tbody></table><p>It can be verified that T285 = P165 = H143 = 40755.</p><p>Find the next triangle number that is also pentagonal and hexagonal.</p><hr><p>可证明任何一个六边形数字必然是三角形数字，证明略。</p><p>可以遍历六边形数字，判断是不是五边形数字。</p><p>判断是不是五边形数字使用二分法。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Triangele</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Pentagonal</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (<span class="hljs-number">3</span> * n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">Hexagonal</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int64_t</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int64_t</span> (*func)(<span class="hljs-keyword">int64_t</span>), <span class="hljs-keyword">int64_t</span> n, <span class="hljs-keyword">int64_t</span> x)</span> </span>&#123; <span class="hljs-comment">// 使用函数指针</span>    <span class="hljs-keyword">int64_t</span> head = <span class="hljs-number">1</span>, tail = n, mid;    <span class="hljs-keyword">while</span> (head &lt;= tail) &#123;        mid = (head + tail) &gt;&gt; <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (func(mid) == x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (func(mid) &lt; x) head = mid + <span class="hljs-number">1</span>;        <span class="hljs-keyword">else</span> tail = mid - <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int64_t</span> n = <span class="hljs-number">143</span>;    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;        n++; <span class="hljs-comment">// 六边形数字下标</span>        <span class="hljs-keyword">int64_t</span> tmp = Hexagonal(n); <span class="hljs-comment">// 遍历六边形数字</span>                <span class="hljs-comment">// 二分判断是否为五边形数字，左右界为2 * n，和tmp</span>        <span class="hljs-keyword">if</span> (!binary_search(Pentagonal, <span class="hljs-number">2</span> * n, tmp)) <span class="hljs-keyword">continue</span>;         <span class="hljs-keyword">break</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%"</span> PRId64 <span class="hljs-string">"\n"</span>, Hexagonal(n));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 函数</title>
    <link href="/2020/08/06/func/"/>
    <url>/2020/08/06/func/</url>
    
    <content type="html"><![CDATA[<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><p>把函数当作参数传入方程中。</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*f1)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span> (*f2)(<span class="hljs-keyword">int</span>), <span class="hljs-keyword">int</span> (*f3)(<span class="hljs-keyword">int</span>))</span> </span>&#123;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-keyword">return</span> f1(x);    &#125;    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">100</span>) &#123;        <span class="hljs-keyword">return</span> f2(x);    &#125;    <span class="hljs-keyword">return</span> f3(x);&#125;</code></pre><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ol><li>边界条件</li><li>处理过程，递归过程</li><li>返回</li></ol><h4 id="与数学归纳法类似"><a href="#与数学归纳法类似" class="headerlink" title="与数学归纳法类似"></a>与数学归纳法类似</h4><ol><li>f(0) 成立                             ==&gt;    边界条件成立</li><li>f(k)成立，f(k+1)成立        ==&gt;    处理过程</li></ol><h1 id="变参函数"><a href="#变参函数" class="headerlink" title="变参函数"></a>变参函数</h1><ul><li>需要引入&lt;cstdarg&gt;头文件</li></ul><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, ...)</span></span>;</code></pre><ul><li>va_list                                        =&gt; 变参列表</li><li>va_start()                                   =&gt; a后面的第一个参数</li><li>va_arg()                                     =&gt; 下一个可变参数列表中的参数</li><li>va_end()                                    =&gt; 结束获取可变参数列表的动作</li></ul><p>例：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max_int</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, ...)</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;    va_list arg;    va_start(arg, n);    <span class="hljs-keyword">while</span> (n--) &#123;        <span class="hljs-keyword">int</span> tmp = va_arg(arg, <span class="hljs-keyword">int</span>);        <span class="hljs-keyword">if</span> (tmp &gt; ans) ans = tmp;    &#125;    va_end(arg);        <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    max_int(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>);    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>function</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划3</title>
    <link href="/2020/08/06/euler03/"/>
    <url>/2020/08/06/euler03/</url>
    
    <content type="html"><![CDATA[<h1 id="Largest-prime-factor"><a href="#Largest-prime-factor" class="headerlink" title="Largest prime factor"></a><strong>Largest prime factor</strong></h1><p>The prime factors of 13195 are 5, 7, 13 and 29.</p><p>What is the largest prime factor of the number 600851475143 ?</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 600851475143LL</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, i = <span class="hljs-number">2</span>;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n = max_n;    <span class="hljs-keyword">while</span> (i * i &lt;= n) &#123;        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) ans = i;        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) n /= i; <span class="hljs-comment">// 除掉所有为i的质因子，本行之后n与i互质</span>        i++;    &#125;    <span class="hljs-keyword">if</span> (n != <span class="hljs-number">1</span>) ans = n;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划15</title>
    <link href="/2020/08/06/euler15/"/>
    <url>/2020/08/06/euler15/</url>
    
    <content type="html"><![CDATA[<h1 id="Lattice-paths"><a href="#Lattice-paths" class="headerlink" title="Lattice paths"></a><strong>Lattice paths</strong></h1><p>Starting in the top left corner of a 2×2 grid, and only being able to move to the right and down, there are exactly 6 routes to the bottom right corner.</p><p>How many such routes are there through a 20×20 grid?</p><h4 id="排列组合解决"><a href="#排列组合解决" class="headerlink" title="排列组合解决"></a>排列组合解决</h4><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> m = <span class="hljs-number">40</span>, n = <span class="hljs-number">20</span>, ans = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (m != <span class="hljs-number">20</span> || n) &#123;        <span class="hljs-keyword">if</span> (m != <span class="hljs-number">20</span>) ans *= m--;        <span class="hljs-keyword">if</span> (n &amp;&amp; ans % n == <span class="hljs-number">0</span>) ans /= n--;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划8</title>
    <link href="/2020/08/04/EP8/"/>
    <url>/2020/08/04/EP8/</url>
    
    <content type="html"><![CDATA[<h2 id="Largest-product-in-a-series"><a href="#Largest-product-in-a-series" class="headerlink" title="Largest product in a series"></a><strong>Largest product in a series</strong></h2><p>The four adjacent digits in the 1000-digit number that have the greatest product are 9 × 9 × 8 × 9 = 5832.</p><pre><code class="hljs plain">73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450</code></pre><p>Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><pre><code class="hljs css">假设有数组<span class="hljs-selector-attr">[a b c d e f g h]</span>一个大小为3的滑动窗口在其上滑动，则有:<span class="hljs-selector-attr">[a b c]</span>  <span class="hljs-selector-attr">[b c d]</span>    <span class="hljs-selector-attr">[c d e]</span>      <span class="hljs-selector-attr">[d e f]</span>        <span class="hljs-selector-attr">[e f g]</span>          <span class="hljs-selector-attr">[f g h]</span></code></pre><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 1000</span><span class="hljs-keyword">char</span> num[max_n + <span class="hljs-number">5</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%s"</span>, num + len)) len = <span class="hljs-built_in">strlen</span>(num);    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>, p = <span class="hljs-number">1</span>, zero = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; num[i]; i++) &#123;        num[i] -= <span class="hljs-string">'0'</span>;        <span class="hljs-keyword">if</span> (num[i]) p *= num[i];        <span class="hljs-keyword">else</span> zero += <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">13</span>) <span class="hljs-keyword">continue</span>;        <span class="hljs-keyword">if</span> (num[i - <span class="hljs-number">13</span>]) p /= num[i - <span class="hljs-number">13</span>];        <span class="hljs-keyword">else</span> zero -= <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (zero == <span class="hljs-number">0</span> &amp;&amp; p &gt; ans) ans = p;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划2</title>
    <link href="/2020/08/04/eulerproject-02/"/>
    <url>/2020/08/04/eulerproject-02/</url>
    
    <content type="html"><![CDATA[<h2 id="Even-Fibonacci-numbers-偶斐波那契数"><a href="#Even-Fibonacci-numbers-偶斐波那契数" class="headerlink" title="Even Fibonacci numbers 偶斐波那契数"></a><strong>Even Fibonacci numbers</strong> <strong>偶斐波那契数</strong></h2><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p><p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …</p><p>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p><h1 id="解1"><a href="#解1" class="headerlink" title="解1"></a>解1</h1><p>数学推导可知:<br>$$<br>fib(n) \geq 1.5^n<br>$$<br>可知最多44项就可满足题目</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 44</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 4000000</span><span class="hljs-keyword">int</span> fib[max_n + <span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= max_n; i++) &#123;        fib[i] = fib[i - <span class="hljs-number">1</span>] + fib[i - <span class="hljs-number">2</span>];    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= max_n; i++) &#123;        <span class="hljs-keyword">if</span> (fib[i] &lt;= N &amp;&amp; !(fib[i] &amp; <span class="hljs-number">1</span>)) sum += fib[i];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>空间复杂度O(n)，不好。</p><h1 id="解2"><a href="#解2" class="headerlink" title="解2"></a>解2</h1><p>每次生成只依赖于前两项的值，因此没必要存储全部斐波那契数列。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 4000000</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (a + b &lt;=  max_n) &#123;        b = a + b;        a = b - a;        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;        sum += b;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="解3"><a href="#解3" class="headerlink" title="解3"></a>解3</h1><h2 id="滚动数组：可循环利用的数组"><a href="#滚动数组：可循环利用的数组" class="headerlink" title="滚动数组：可循环利用的数组"></a>滚动数组：可循环利用的数组</h2><p>[0, 1] =&gt; [2, 1] =&gt; [2, 3] =&gt; [5, 3] =&gt; ……</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> max_n 4000000</span><span class="hljs-keyword">int</span> fib[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>, n = <span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span> (fib[n % <span class="hljs-number">2</span>] + fib[(n - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] &lt;= max_n) &#123;        n++;        fib[n % <span class="hljs-number">2</span>] = fib[(n - <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>] + fib[(n - <span class="hljs-number">2</span>) % <span class="hljs-number">2</span>];        <span class="hljs-keyword">if</span> (fib[n % <span class="hljs-number">2</span>] &amp; <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;        sum += fib[n % <span class="hljs-number">2</span>];    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL标准库实现2——Vector 实现</title>
    <link href="/2020/08/03/cpp-stl-vector/"/>
    <url>/2020/08/03/cpp-stl-vector/</url>
    
    <content type="html"><![CDATA[<h1 id="vector-介绍"><a href="#vector-介绍" class="headerlink" title="vector 介绍"></a>vector 介绍</h1><p>vector 是 C++ 标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector 是向量类型，它可以容纳多种类型的数据，所以称之为容器。</p><h1 id="vector-类基础"><a href="#vector-类基础" class="headerlink" title="vector 类基础"></a>vector 类基础</h1><pre><code class="hljs cpp"><span class="hljs-keyword">private</span>:    T *start_;<span class="hljs-comment">// 表示使用空间的头</span>    T *finish_;<span class="hljs-comment">// 表示使用空间的末尾</span>    T *endofStorage_;<span class="hljs-comment">// 表示可用空间的末尾</span>    <span class="hljs-keyword">typedef</span> Alloc dataAllocator;<span class="hljs-comment">// 表示分配空间</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django ModelAdmin的使用</title>
    <link href="/2020/07/31/django-model-admin/"/>
    <url>/2020/07/31/django-model-admin/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  若想在Admin中管理自己定义的model，需要在app下的admin.py中创建ModelAdmin。</p></blockquote><h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-keyword">from</span> myproject.myapp.models <span class="hljs-keyword">import</span> Author<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    <span class="hljs-keyword">pass</span>admin.site.register(Author, AuthorAdmin)</code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Author<span class="hljs-meta">@admin.register(Author)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    <span class="hljs-keyword">pass</span></code></pre><p>或者直接</p><pre><code class="hljs pyth">from django.contrib import adminfrom myproject.myapp.models import Authoradmin.site.register(Author)</code></pre><p>注册后可在admin页面中管理’Author’ Model。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="1-fields-exclude"><a href="#1-fields-exclude" class="headerlink" title="1. fields, exclude"></a>1. fields, exclude</h2><p>在编辑页面中包含或除去某些字段</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    fields = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'title'</span>) <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    exclude = (<span class="hljs-string">'birth_date'</span>,)</code></pre><h2 id="2-fieldsets"><a href="#2-fieldsets" class="headerlink" title="2. fieldsets"></a>2. fieldsets</h2><p>如上fields的加强版</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlatPageAdmin</span><span class="hljs-params">(admin.ModelAdmin)</span>:</span>    fieldsets = (        (<span class="hljs-literal">None</span>, &#123;            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'url'</span>, <span class="hljs-string">'title'</span>, <span class="hljs-string">'content'</span>, <span class="hljs-string">'sites'</span>)        &#125;),        (<span class="hljs-string">'Advanced options'</span>, &#123;            <span class="hljs-string">'classes'</span>: (<span class="hljs-string">'collapse'</span>,),            <span class="hljs-string">'fields'</span>: (<span class="hljs-string">'registration_required'</span>, <span class="hljs-string">'template_name'</span>),        &#125;),    )</code></pre>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++的运算符及部分数学函数</title>
    <link href="/2020/07/30/operator/"/>
    <url>/2020/07/30/operator/</url>
    
    <content type="html"><![CDATA[<h1 id="1-位运算符-amp-、-、-、"><a href="#1-位运算符-amp-、-、-、" class="headerlink" title="1. 位运算符(&amp;、|、^、~ )"></a>1. 位运算符(&amp;、|、^、~ )</h1><table><thead><tr><th align="left">p</th><th align="left">q</th><th align="left">p &amp; q</th><th align="left">p | q</th><th align="left">p ^ q</th></tr></thead><tbody><tr><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">0</td><td align="left">1</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr><tr><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">1</td><td align="left">0</td></tr><tr><td align="left">1</td><td align="left">0</td><td align="left">0</td><td align="left">1</td><td align="left">1</td></tr></tbody></table><blockquote><p>  假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p></blockquote><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&amp;</td><td align="left">按位与操作，按二进制位进行”与”运算。运算规则：<code>0&amp;0=0;    0&amp;1=0;     1&amp;0=0;      1&amp;1=1;</code></td><td align="left">(A &amp; B) 将得到 12，即为 0000 1100</td></tr><tr><td align="left">|</td><td align="left">按位或运算符，按二进制位进行”或”运算。运算规则：`0</td><td align="left">0=0;    0</td></tr><tr><td align="left">^</td><td align="left">异或运算符，按二进制位进行”异或”运算。运算规则：<code>0^0=0;    0^1=1;    1^0=1;   1^1=0;</code></td><td align="left">(A ^ B) 将得到 49，即为 0011 0001</td></tr><tr><td align="left">~</td><td align="left">取反运算符，按二进制位进行”取反”运算。运算规则：<code>~1=0;    ~0=1;</code></td><td align="left">(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td></tr></tbody></table><h1 id="2-左移右移-lt-lt-、-gt-gt"><a href="#2-左移右移-lt-lt-、-gt-gt" class="headerlink" title="2. 左移右移(&lt;&lt;、&gt;&gt;)"></a>2. 左移右移(&lt;&lt;、&gt;&gt;)</h1><blockquote><p>  假设变量 <strong>A</strong> 的值为 60，变量 <strong>B</strong> 的值为 13，则：</p></blockquote><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">实例</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0，相当于原值*2。</td><td align="left">A &lt;&lt; 2 将得到 240，即为 1111 0000</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃，相当于原值/2。</td><td align="left">A &gt;&gt; 2 将得到 15，即为 0000 1111</td></tr></tbody></table><h1 id="3-下取整-floor"><a href="#3-下取整-floor" class="headerlink" title="3. 下取整 floor()"></a>3. 下取整 floor()</h1><ul><li>头文件math.h</li><li>原型：int floor(double x)</li></ul><h1 id="4-取整数绝对值-abs"><a href="#4-取整数绝对值-abs" class="headerlink" title="4. 取整数绝对值 abs()"></a>4. 取整数绝对值 abs()</h1><ul><li>头文件 stdlib.h</li><li>原型：int abs(int x)</li></ul><h1 id="5-取实数绝对值-fabs"><a href="#5-取实数绝对值-fabs" class="headerlink" title="5. 取实数绝对值 fabs()"></a>5. 取实数绝对值 fabs()</h1><ul><li>math.h</li><li>double fabs(double x)</li></ul><h1 id="6-取e的对数-log"><a href="#6-取e的对数-log" class="headerlink" title="6. 取e的对数 log()"></a>6. 取e的对数 log()</h1><ul><li>math.h</li><li>double log(double x)</li></ul><h1 id="7-取10的对数-log10"><a href="#7-取10的对数-log10" class="headerlink" title="7. 取10的对数 log10()"></a>7. 取10的对数 log10()</h1><ul><li>math.h</li><li>double log19(double x)</li></ul><h1 id="8-arccos，acos"><a href="#8-arccos，acos" class="headerlink" title="8. arccos，acos()"></a>8. arccos，acos()</h1><ul><li>math.h</li><li>double acos(double x)</li></ul><blockquote><p>  acos(-1) = pi</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>operator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu安装MySQL踩坑</title>
    <link href="/2020/07/29/ubuntu-mysql/"/>
    <url>/2020/07/29/ubuntu-mysql/</url>
    
    <content type="html"><![CDATA[<h1 id="在阿里云Ubuntu主机上安装MySQL"><a href="#在阿里云Ubuntu主机上安装MySQL" class="headerlink" title="在阿里云Ubuntu主机上安装MySQL"></a>在阿里云Ubuntu主机上安装MySQL</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><p>运行如下命令</p><pre><code class="hljs bash">sudo apt-get install mysql-serversudo apt-get isntall mysql-clientsudo apt-get install libmysqlclient-dev</code></pre><h2 id="2-改密码（天坑）"><a href="#2-改密码（天坑）" class="headerlink" title="2. 改密码（天坑）"></a>2. 改密码（天坑）</h2><h4 id="1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf"><a href="#1-sudo-vim-etc-mysql-mysql-conf-d-mysqld-cnf" class="headerlink" title="1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf"></a>1. sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf</h4><p>找到如下内容</p><pre><code class="hljs plain">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 skip-grant-tables</code></pre><p>添加 skip-grant-tables</p><p>以安全模式启动MySQL</p><h4 id="2-sudo-service-mysql-restart"><a href="#2-sudo-service-mysql-restart" class="headerlink" title="2. sudo service mysql restart"></a>2. sudo service mysql restart</h4><p>重启mysql服务</p><p>MySQL启动之后就可以不用密码登陆了</p><h4 id="3-查看一下user表"><a href="#3-查看一下user表" class="headerlink" title="3. 查看一下user表"></a>3. 查看一下user表</h4><pre><code class="hljs bash">mysql&gt; select user, plugin from mysql.user;+------------------+-----------------------+| user             | plugin                |+------------------+-----------------------+| root             | auth_socket           || mysql.session    | mysql_native_password || mysql.sys        | mysql_native_password || debian-sys-maint | mysql_native_password |+------------------+-----------------------+4 rows <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span> (0.00 sec)</code></pre><h4 id="4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’"><a href="#4-（重点）update-mysql-user-set-authentication-string-PASSWORD-‘newPwd’-plugin-’mysql-native-password’-where-user-’root’" class="headerlink" title="4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;"></a>4. （重点）update mysql.user set authentication_string=PASSWORD(‘newPwd’), plugin=’mysql_native_password’ where user=’root’;</h4><p>需要将root的plugin修改为mysql_native_password</p><h4 id="5-flush-privileges"><a href="#5-flush-privileges" class="headerlink" title="5. flush privileges;"></a>5. flush privileges;</h4><p>刷新权限</p><h4 id="6-将mysqld-cnf改回，重启MySQL服务"><a href="#6-将mysqld-cnf改回，重启MySQL服务" class="headerlink" title="6. 将mysqld.cnf改回，重启MySQL服务"></a>6. 将mysqld.cnf改回，重启MySQL服务</h4><pre><code class="hljs bas">31 user        &#x3D; mysql32 pid-file    &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.pid33 socket      &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sock34 port        &#x3D; 330635 basedir     &#x3D; &#x2F;usr36 datadir     &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql37 tmpdir      &#x3D; &#x2F;tmp38 lc-messages-dir &#x3D; &#x2F;usr&#x2F;share&#x2F;mysql39 skip-external-locking40 # skip-grant-tables</code></pre><h1 id="3-改编码方式"><a href="#3-改编码方式" class="headerlink" title="3. 改编码方式"></a>3. 改编码方式</h1><p>默认安装MySQL后编码方式不一定是utf8，这时如果我们往数据库中添加含中文的记录会报错。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Development</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉计划1 &amp; 6</title>
    <link href="/2020/07/28/eulerproject-00/"/>
    <url>/2020/07/28/eulerproject-00/</url>
    
    <content type="html"><![CDATA[<h2 id="01-Multiples-of-3-and-5"><a href="#01-Multiples-of-3-and-5" class="headerlink" title="01. Multiples of 3 and 5"></a><strong>01. Multiples of 3 and 5</strong></h2><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.</p><p>Find the sum of all the multiples of 3 or 5 below 1000.</p><blockquote><p>   暴力解 </p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">is_val</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;    <span class="hljs-keyword">return</span> n % <span class="hljs-number">3</span> == <span class="hljs-number">0</span> || n % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;        <span class="hljs-keyword">if</span> (is_val(i)) res += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, res);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(n)</li></ul><blockquote><p>  等差</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum_3 = (<span class="hljs-number">3</span> + <span class="hljs-number">999</span>) * <span class="hljs-number">333</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_5 = (<span class="hljs-number">5</span> + <span class="hljs-number">995</span>) * <span class="hljs-number">199</span> / <span class="hljs-number">2</span>;    <span class="hljs-keyword">int</span> sum_15 = (<span class="hljs-number">15</span> + <span class="hljs-number">999</span> / <span class="hljs-number">15</span> * <span class="hljs-number">15</span>) * (<span class="hljs-number">999</span> / <span class="hljs-number">15</span>) / <span class="hljs-number">2</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum_3 + sum_5 - sum_15);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><ul><li>时间复杂度O(1)</li></ul><h2 id="06-Sum-square-difference"><a href="#06-Sum-square-difference" class="headerlink" title="06. Sum square difference"></a><strong>06. Sum square difference</strong></h2><p>The sum of the squares of the first ten natural numbers is,</p><p>12 + 22 + … + 102 = 385</p><p>The square of the sum of the first ten natural numbers is,</p><p>(1 + 2 + … + 10)2 = 552 = 3025</p><p>Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 − 385 = 2640.</p><p>Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.</p><blockquote><p>  老规矩，暴力解，O(n)</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">int</span> sum_of_squ = <span class="hljs-number">0</span>; squ_of_sum = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i += <span class="hljs-number">1</span>) &#123;        sum_of_sqq += i * i;        squ_of_sum += i;    &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, squ_of_sum * squ_of_sum - sum_of_squ);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><blockquote><p>  去for循环，公式自行百度</p></blockquote><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> n 100</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> sum2 = <span class="hljs-number">5050</span>;    <span class="hljs-keyword">int</span> sum1 = (<span class="hljs-number">2</span> * n * n * n + <span class="hljs-number">3</span> * n * n + n) / <span class="hljs-number">6</span>;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, sum2 * sum2 - sum1);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><a href="https://www.zhihu.com/question/32253765" target="_blank" rel="noopener">正整数的平方和公式是什么？怎么证明？</a></p>]]></content>
    
    
    <categories>
      
      <category>course</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Euler project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++STL标准库实现1——模板编程</title>
    <link href="/2020/07/28/cpp-stl-template/"/>
    <url>/2020/07/28/cpp-stl-template/</url>
    
    <content type="html"><![CDATA[<h1 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h1><h2 id="模板的基本语法"><a href="#模板的基本语法" class="headerlink" title="模板的基本语法"></a>模板的基本语法</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span>/<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span></code></pre><p>template 告诉编译器，接下来是一个模板 ，typename 和 class 都是关键字，在这里二者可以互用没有区别。在<code>&lt; &gt;</code>中 <code>T</code> 叫做模板形参，一旦模板被实例化，<code>T</code> 也会变成具体的类型。</p><h2 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<span class="hljs-function">T  <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span><span class="hljs-function"></span>&#123;    T a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><p>使用：</p><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> a ;    a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> lva ,<span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> rva)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">double</span> a ;     a = lva + rva ;<span class="hljs-keyword">return</span> a;&#125;</code></pre><blockquote><p>  如果我们使用<code>add(1,2.0)</code>是会报错的，编译器无法找到<code>add(int,double)</code>。</p></blockquote><h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    T a;    <span class="hljs-keyword">public</span>:        <span class="hljs-function">T <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T lva ,<span class="hljs-keyword">const</span> T rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">T</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> T lva, <span class="hljs-keyword">const</span> T rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><p>在程序中给出模板并不能使用它，还必须实例化，比如：</p><pre><code class="hljs c++">Myclass&lt;<span class="hljs-keyword">int</span>&gt; A； <span class="hljs-comment">//用 int 实例化一个类 A</span>Myclass&lt;<span class="hljs-keyword">double</span>&gt; B； <span class="hljs-comment">//用 double 实例化一个类 B</span></code></pre><h2 id="成员模板："><a href="#成员模板：" class="headerlink" title="成员模板："></a>成员模板：</h2><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;</code></pre><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-keyword">public</span>:       T a;       <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> type_1 , <span class="hljs-keyword">typename</span> type_2&gt;        <span class="hljs-function">type_1 <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_1 lva ,<span class="hljs-keyword">const</span> type_2 rva)</span></span>;        <span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">type_3</span>&gt;</span><span class="hljs-class">        <span class="hljs-title">class</span> <span class="hljs-title">Myclass_2</span>;</span>         <span class="hljs-comment">// 声明放在这里，具体定义放在类外进行。</span>        Myclass_2&lt;T&gt; C;          <span class="hljs-comment">// 定义一个Myclass_2 类 A。使用 T 进行实例化</span>&#125;;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;typename type_1,typename type_2&gt;</span><span class="hljs-class"><span class="hljs-title">type_1</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:add(<span class="hljs-keyword">const</span> type_1 lva, <span class="hljs-keyword">const</span> type_2 rva)&#123;    a = lva + rva;    <span class="hljs-keyword">return</span> a;&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class">    <span class="hljs-title">template</span> &lt;class type_3&gt;</span><span class="hljs-class">    <span class="hljs-title">class</span> <span class="hljs-title">Myclass</span>&lt;T&gt;:</span>:Myclass_2    &#123;        <span class="hljs-keyword">public</span>:            type_3 value;            <span class="hljs-function">type_3 <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">const</span> type_3 a , <span class="hljs-keyword">const</span> type_3 b)</span> </span>&#123;vlaue = a - b;&#125;    &#125;;</code></pre><h2 id="typename和class的区别"><a href="#typename和class的区别" class="headerlink" title="typename和class的区别"></a>typename和class的区别</h2><p><code>typename</code>和<code>class</code>是模板中经常使用的两个关键词 ，在模板定义的时候没有什么区别。以前用的是 class，后来 c++ 委员会加入了 typename。<strong>因为历史原因，两个是可以通用的。</strong></p><p>例子：</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Myclass</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass();        <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> test;  <span class="hljs-comment">//定义类型别名</span>&#125;<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;</span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">Myclass2</span>&#123;</span>    <span class="hljs-keyword">public</span>:        Myclass2();        T::test *a  <span class="hljs-comment">// 声明一个指向T::test类型的指针。</span>        <span class="hljs-comment">//   typename T::test * a</span>&#125;</code></pre><p>不能通过编译，因为在 c++ 中，允许我们在类中定义一个类型别名，且使用的时候和类名访问类成员的方法一样。这样编译器在编译的时候就会产生二义性，它根本不知道这是一个类型还是别名，所以我们加上 typename 显式说明出来。</p><p>当然如果这里没有二义性，比如<code>Myclass ::test * a</code> ,加上 typename 是会报错的。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Development</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django一些常用操作</title>
    <link href="/2020/07/27/Django/"/>
    <url>/2020/07/27/Django/</url>
    
    <content type="html"><![CDATA[<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="数据中有”-lt-”类似符号"><a href="#数据中有”-lt-”类似符号" class="headerlink" title="数据中有”&lt;”类似符号"></a>数据中有”&lt;”类似符号</h1><p>当传到template中的数据包含”&lt;”之类的符号，例如传入html片段时，若直接使用<h1 id="判断用户是否登录"><a href="#判断用户是否登录" class="headerlink" title="判断用户是否登录"></a>判断用户是否登录</h1><pre><code class="hljs python">request.user.is_authenticated</code></pre><h1 id="需要用户登录"><a href="#需要用户登录" class="headerlink" title="需要用户登录"></a>需要用户登录</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.mixins <span class="hljs-keyword">import</span> LoginRequiredMixin<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span><span class="hljs-params">(LoginRequiredMixin, View)</span>:</span>    login_url = <span class="hljs-string">'/login/'</span>    redirect_field_name = <span class="hljs-string">'redirect_to'</span></code></pre><p>或者</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib.auth.decorators <span class="hljs-keyword">import</span> login_required<span class="hljs-meta">@login_required</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_view</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="Model中datetime默认为当前时间"><a href="#Model中datetime默认为当前时间" class="headerlink" title="Model中datetime默认为当前时间"></a>Model中datetime默认为当前时间</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.timezone <span class="hljs-keyword">import</span> nowmodels.DateTimeField(default=now)</code></pre><h1 id="图片删除"><a href="#图片删除" class="headerlink" title="图片删除"></a>图片删除</h1><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(self, using=None, keep_parents=False)</span>:</span>    storage, path = self.image.storage, self.image.path    storage.delete(path)    super(NepArticleImage, self).delete()</code></pre><h1 id="3-0后xframe显示"><a href="#3-0后xframe显示" class="headerlink" title="3.0后xframe显示"></a>3.0后xframe显示</h1><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.views.decorators.clickjacking <span class="hljs-keyword">import</span> xframe_options_exempt<span class="hljs-meta">@xframe_options_exempt</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__</span><span class="hljs-params">(request)</span>:</span>    ...</code></pre><h1 id="数据中有”-lt-”类似符号"><a href="#数据中有”-lt-”类似符号" class="headerlink" title="数据中有”&lt;”类似符号"></a>数据中有”&lt;”类似符号</h1><p>当传到template中的数据包含”&lt;”之类的符号，例如传入html片段时，若直接使用{{ content }}会导致”&lt;”被转码，进而使”&lt;”变为”&amp;gt;”。如：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>ssdasdsa<span class="hljs-symbol">&amp;lt;</span>/p<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> // <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ssdasdsa<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>需要改为一下写法：</p><pre><code class="hljs plain">&#123;&#123; content | safe &#125;&#125;</code></pre><p>其中 safe可以防止转意。</p>会导致”&lt;”被转码，进而使”&lt;”变为”&amp;gt;”。如：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-symbol">&amp;lt;</span>p<span class="hljs-symbol">&amp;gt;</span>ssdasdsa<span class="hljs-symbol">&amp;lt;</span>/p<span class="hljs-symbol">&amp;gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> // <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>ssdasdsa<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre><p>需要改为一下写法：</p><pre><code class="hljs plain">&#123;&#123; content | safe &#125;&#125;</code></pre><p>其中 safe可以防止转意。</p>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCP/IP的部分知识</title>
    <link href="/2020/06/17/tcpip/"/>
    <url>/2020/06/17/tcpip/</url>
    
    <content type="html"><![CDATA[<h1 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h1><p>应用层</p><p>表示层</p><p>会话层</p><p>传输层</p><p>网络层</p><p>链路层</p><p>物理层</p><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><p>应用层</p><p>传输层</p><p>网际层</p><p>网络接口层</p><p>硬件层</p><h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><h2 id="第-1-次握手"><a href="#第-1-次握手" class="headerlink" title="第 1 次握手"></a>第 1 次握手</h2><p>客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里。</p><h2 id="第-2-次握手"><a href="#第-2-次握手" class="headerlink" title="第 2 次握手"></a>第 2 次握手</h2><p>服务器发回确认包(ACK)应答。即SYN标志位和ACK标志位均为1同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。</p><h2 id="第-3-次握手"><a href="#第-3-次握手" class="headerlink" title="第 3 次握手"></a>第 3 次握手</h2><p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h2 id="第1次挥手"><a href="#第1次挥手" class="headerlink" title="第1次挥手"></a>第1次挥手</h2><p>Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p><h2 id="第2次挥手"><a href="#第2次挥手" class="headerlink" title="第2次挥手"></a>第2次挥手</h2><p>Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p><h2 id="第3次挥手"><a href="#第3次挥手" class="headerlink" title="第3次挥手"></a>第3次挥手</h2><p>Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p><h2 id="第4次挥手"><a href="#第4次挥手" class="headerlink" title="第4次挥手"></a>第4次挥手</h2><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p><h1 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h1><p><strong>1．为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？</strong></p><p>这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。</p><p><strong>2. 为什么不能用两次握手进行连接？</strong></p><p>我们知道，3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。<br>  现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p><blockquote><p>  Linux 环境下可用tcpdump查看整个过程。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Dev</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
